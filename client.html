<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        /* Base styles from user's code */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #2f3136; }
        ::-webkit-scrollbar-thumb { background: #4f545c; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #72767d; }
        html, body { height: 100%; margin: 0; font-family: 'Inter', sans-serif; overflow: hidden; background-color: #36393f; color: #dcddde;}

        :root {
            --theme-color-primary: #5865f2;
            --theme-color-primary-hover: #4752c4;
        }

        input[type="text"], input[type="password"], input[type="number"], textarea, select {
            color: #dcddde !important;
            background-color: #202225;
            border: 1px solid #40444b !important;
        }
        input::placeholder, textarea::placeholder { color: #72767d; }
        select option { background-color: #202225; color: #dcddde; }
        input:focus, textarea:focus, select:focus {
             border-color: var(--theme-color-primary) !important;
             outline: none !important;
             box-shadow: 0 0 0 2px rgba(var(--theme-color-primary-rgb, 88, 101, 242), 0.3);
        }
        textarea {
            color: #dcddde !important;
        }
        #recent-posts-feed .post-item p {
            word-break: break-word;
        }
        @media (max-width: 767px) {
            #right-sidebar {
                display: none;
            }
        }

        /* Message and Channel styles */
        .message { display: flex; align-items: flex-start; padding: 8px 16px; margin-bottom: 4px; border-radius: 8px; transition: background-color 0.2s ease; position: relative; }
        .message:hover { background-color: rgba(255, 255, 255, 0.02); }
        .message-avatar { width: 40px; height: 40px; border-radius: 50%; margin-right: 12px; flex-shrink: 0; display: flex; align-items: center; justify-content: center; font-weight: bold; color: white; }
        .message-avatar img { width: 100%; height: 100%; object-fit: cover; border-radius: 50%; }
        .message-content { display: flex; flex-direction: column; min-width: 0; width: 100%; }
        .message-sender { font-weight: 600; color: #ffffff; margin-bottom: 2px; font-size: 0.9rem; }
        .message-text { color: #dcddde; font-size: 0.95rem; word-wrap: break-word; white-space: pre-wrap; }
        .message-text img.rendered-image { max-width: 100%; max-height: 300px; border-radius: 6px; margin-top: 5px; cursor: pointer; display: block; }
        .message-timestamp { font-size: 0.7rem; color: #72767d; margin-left: 8px; }
        .delete-message-btn { position: absolute; top: 4px; right: 8px; background: none; border: none; color: #72767d; font-size: 0.9rem; cursor: pointer; padding: 2px; line-height: 1; opacity: 0; transition: opacity 0.2s ease; z-index: 10; }
        .message:hover .delete-message-btn { opacity: 1; }
        .delete-message-btn:hover { color: #f04747; }
        .channel-item { display: flex; align-items: center; justify-content: space-between; padding: 6px 8px; border-radius: 6px; cursor: pointer; color: #8e9297; font-weight: 500; transition: background-color 0.2s ease, color 0.2s ease; }
        .channel-item-name-group { display: flex; align-items: center; flex-grow: 1; }
        .channel-item:hover { background-color: #3a3c43; color: #dcddde; }
        .channel-item.active { background-color: var(--theme-color-primary-hover); color: #ffffff; }
        .channel-icon { margin-right: 8px; color: #72767d; width: 16px; text-align: center;}
        .channel-item.active .channel-icon { color: #ffffff; }
        .delete-channel-btn { background: none; border: none; color: #72767d; font-size: 0.8rem; cursor: pointer; padding: 2px 4px; line-height: 1; display: none; flex-shrink: 0; }
        .channel-item:hover .delete-channel-btn { display: inline-block; }
        .delete-channel-btn:hover { color: #f04747; }

        /* Auth and Connection Failed styles */
        .full-page-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; color: #dcddde; text-align: center; background-color: #36393f; }
        #auth-container { background-color: rgba(40, 43, 48, 0.95); }
        #auth-server-icon { width: 80px; height: 80px; border-radius: 12px; margin-bottom: 15px; object-fit: cover; box-shadow: 0 2px 8px rgba(0,0,0,0.3); display: none; }
        #auth-server-name { font-size: 2rem; font-weight: bold; color: #fff; margin-bottom: 20px; text-shadow: 0 1px 3px rgba(0,0,0,0.3); }
        .auth-form { background-color: #36393f; padding: 25px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); width: 350px; }
        .auth-form h2 { text-align: center; color: #fff; margin-bottom: 20px; font-size: 1.5rem; }
        .auth-form input { width: 100%; padding: 10px; margin-bottom: 15px; border-radius: 5px; box-sizing: border-box; }
        .auth-form button { width: 100%; padding: 10px; border-radius: 5px; border: none; background-color: var(--theme-color-primary); color: white; font-weight: bold; cursor: pointer; transition: background-color 0.2s ease; }
        .auth-form button:hover { background-color: var(--theme-color-primary-hover); }
        .auth-form button:disabled { background-color: #4f545c; cursor: not-allowed; }
        .auth-form .toggle-auth { text-align: center; margin-top: 15px; font-size: 0.9rem; color: #72767d; cursor: pointer; }
        .auth-form .toggle-auth:hover { text-decoration: underline; color: #b9bbbe; }
        .auth-error { color: #f04747; text-align: center; margin-bottom:10px; font-size: 0.85rem; }
        #connection-failed-container .icon { font-size: 4rem; margin-bottom: 20px; color: #72767d; }
        #connection-failed-container p { font-size: 1.1rem; margin-bottom: 25px; }
        #connection-failed-container button { padding: 10px 20px; border-radius: 5px; border: none; background-color: var(--theme-color-primary); color: white; font-weight: bold; cursor: pointer; transition: background-color 0.2s ease; }
        #connection-failed-container button:hover { background-color: var(--theme-color-primary-hover); }
        #connection-failed-container button:disabled { background-color: #4f545c; cursor: not-allowed; }
        #status-indicator { position: fixed; bottom: 20px; right: 20px; padding: 10px 15px; background-color: #202225; color: #fff; border-radius: 6px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 1001; font-size: 0.9rem; }
        #status-indicator.error { background-color: #f04747; }

        /* Admin Panel and Server Banner styles */
        .admin-input-group { margin-bottom: 10px; }
        .admin-input-group label { display: block; font-size: 0.8rem; color: #8e9297; margin-bottom: 3px; }
        .admin-input-group input[type="text"], .admin-input-group input[type="number"], .admin-input-group select { width: 100%; padding: 8px; border-radius: 3px; box-sizing: border-box; }
        .admin-input-group input[type="checkbox"] { margin-right: 5px; vertical-align: middle; }
        #server-banner-container { width: 100%; height: 60px; background-color: #202225; background-size: cover; background-position: center; display: flex; align-items: center; padding-left: 10px; border-bottom: 1px solid #202225; }
        #sidebar-server-icon { width: 32px; height: 32px; border-radius: 6px; margin-right: 10px; object-fit: cover; display: none; }
        #server-name-header { padding: 0; font-size: 1.1rem; font-weight: 600; color: #ffffff; text-align: left; flex-grow: 1; }

        /* Thread and other specific styles */
        .thread-list-item { padding: 10px; margin-bottom: 8px; background-color: #292b2f; border-radius: 6px; cursor: pointer; transition: background-color 0.2s ease; border-left: 3px solid transparent; }
        .thread-list-item:hover { background-color: #303338; border-left-color: var(--theme-color-primary-hover); }
        .thread-list-item.active-thread { background-color: #3a3c43; border-left-color: var(--theme-color-primary); }
        .thread-title { font-size: 1rem; font-weight: 600; color: #fff; margin-bottom: 4px; }
        .thread-meta { font-size: 0.75rem; color: #72767d; margin-bottom: 6px; }
        .thread-meta span { margin-right: 8px; }
        .thread-snippet { font-size: 0.85rem; color: #b9bbbe; max-height: 40px; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; margin-top: 4px; }
        .thread-actions { margin-top: 8px; display: flex; align-items: center; }
        .upvote-btn { background: none; border: 1px solid #4f545c; color: #b9bbbe; padding: 3px 8px; border-radius: 15px; font-size: 0.75rem; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; }
        .upvote-btn:hover { border-color: var(--theme-color-primary); color: var(--theme-color-primary); }
        .upvote-btn.upvoted { background-color: var(--theme-color-primary); border-color: var(--theme-color-primary); color: white; }
        .upvote-btn i { margin-right: 4px; }
        .upvote-count { margin-left: 6px; }

        #general-char-counter, #reply-char-counter, #thread-create-char-counter, #modal-create-post-char-count { position: absolute; bottom: -18px; right: 5px; font-size: 0.75rem; color: #72767d; }
        #general-char-counter.limit-exceeded, #reply-char-counter.limit-exceeded, #thread-create-char-counter.limit-exceeded, #modal-create-post-char-count.limit-exceeded { color: #f04747; font-weight: bold; }
        .imageboard-gallery { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 1rem; }
        .gallery-item img { width: 100%; height: 100%; object-fit: cover; transition: transform 0.3s ease-in-out; }
        .gallery-item:hover img { transform: scale(1.05); }
        .gallery-item-overlay { transition: opacity 0.3s ease-in-out; }

        /* Sidebar Styles for Mobile Toggle */
        #sidebar { transition: transform 0.3s ease-in-out; }
        @media (max-width: 767px) { /* md breakpoint */
            #sidebar { position: fixed; top: 0; left: 0; bottom: 0; z-index: 100; transform: translateX(-100%); }
            #sidebar.open { transform: translateX(0); }
            body.sidebar-open-overlay::before { content: ""; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.5); z-index: 99; }
        }
        #sidebar-toggle-btn { display: none; }
        @media (max-width: 767px) { #sidebar-toggle-btn { display: inline-block; } }

        /* Image Modal styles */
        #image-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.85); display: none; align-items: center; justify-content: center; z-index: 2000; cursor: zoom-out; }
        #image-modal img { max-width: 90vw; max-height: 90vh; object-fit: contain; border-radius: 8px; box-shadow: 0 0 30px rgba(0,0,0,0.5); }

        /* Styles for Settings Modal and Tabs */
        .tab-active {
            border-bottom-color: var(--theme-color-primary);
            color: var(--theme-color-primary);
        }
        .modal-transition {
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }
        .modal-hidden {
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
        }
        .modal-visible {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }
        #settingsModal input[type="text"], #settingsModal input[type="number"], #settingsModal select, #settingsModal textarea {
            color: #dcddde !important; background-color: #2b2d31; border: 1px solid #40444b !important;
        }
        #settingsModal input::placeholder, #settingsModal textarea::placeholder { color: #72767d; }
        #settingsModal select option { background-color: #2b2d31; color: #dcddde; }
        #settingsModal input:focus, #settingsModal textarea:focus, #settingsModal select:focus {
             border-color: var(--theme-color-primary) !important;
             box-shadow: 0 0 0 2px rgba(var(--theme-color-primary-rgb, 88, 101, 242), 0.3);
        }
        
        /* Grape Pack, File Sending, Emoji/Sticker Picker Styles */
        .inline-emoji { 
            max-height: 1.8em; 
            vertical-align: bottom; 
            margin: 0 0.05em;
            display: inline-block; 
        }
        .chat-sticker { 
            max-width: 128px; 
            max-height: 128px;
            display: block; 
            margin-top: 5px;
            margin-bottom: 5px;
            border-radius: 4px;
            background-color: rgba(0,0,0,0.1); 
        }
        .file-link i {
            margin-right: 0.3em;
        }
        .emoji-sticker-picker-panel-base {
            position: absolute;
            bottom: calc(100% + 5px); 
            left: 0;
            width: 320px; 
            max-height: 250px; 
            background-color: #2f3136;
            border: 1px solid #40444b;
            border-radius: 8px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.3);
            padding: 10px;
            overflow-y: auto;
            z-index: 100;
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(48px, 1fr)); 
            gap: 8px;
        }
        .emoji-sticker-picker-panel-base .picker-item { 
            width: 100%;
            height: auto;
            cursor: pointer;
            border-radius: 4px;
            transition: transform 0.1s ease-in-out, background-color 0.1s ease;
            padding: 4px; 
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .emoji-sticker-picker-panel-base .picker-item:hover {
            transform: scale(1.1);
            background-color: #40444b;
        }
        .emoji-sticker-picker-panel-base .picker-item img.picker-emoji {
             max-width: 32px; 
             max-height: 32px;
        }
        .emoji-sticker-picker-panel-base .picker-item img.picker-sticker {
             max-width: 100%; 
             max-height: 48px; 
        }
        .grape-pack-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid #40444b;
        }
        .grape-pack-item:last-child {
            border-bottom: none;
        }
        .remove-grape-pack-btn {
            background-color: #f04747;
            color: white;
            border: none;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
        }
        .remove-grape-pack-btn:hover {
            background-color: #d32f2f;
        }
        .message-input-actions button {
            background: none;
            border: none;
            color: #b9bbbe; 
            font-size: 1.1rem; 
            padding: 6px;
            border-radius: 4px;
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        .message-input-actions button:hover {
            background-color: #40444b; 
            color: #ffffff;
        }
        .message-input-actions button:disabled {
            color: #72767d;
            cursor: not-allowed;
        }
        .message-input-actions button:disabled:hover {
            background-color: transparent;
        }
        
        /* MODIFIED: Center content area to ensure message list can scroll properly */
        #center-content-area {
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }
        /* MODIFIED: Message list container to fill available space and scroll */
        #message-list-container {
            flex-grow: 1; /* Allows it to take up available vertical space */
            overflow-y: auto; /* Enables vertical scrolling */
             /* padding and space-y are fine */
        }

    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body class="text-gray-200 flex h-screen overflow-hidden bg-gray-800">

    <div id="connection-failed-container" class="full-page-container" style="display: none;">
        <div class="icon">:(</div> <p id="connection-failed-message">Couldn't connect to server. Maybe it's down or check your internet connection.</p>
        <button id="retry-connection-btn">Retry Connection</button>
    </div>

    <div id="auth-container" class="full-page-container" style="display: none;">
        <img id="auth-server-icon" src="" alt="Server Icon">
        <div id="auth-server-name">Haven Chat</div>
        <div class="auth-form">
            <h2 id="auth-title">Login</h2>
            <div id="auth-error-message" class="auth-error" style="display: none;"></div>
            <input type="text" id="username-input" placeholder="Username" autocomplete="username">
            <input type="password" id="password-input" placeholder="Password" autocomplete="current-password">
            <button id="auth-button" disabled>Login</button>
            <p id="toggle-auth-mode" class="toggle-auth">Need an account? Register</p>
        </div>
    </div>

    <div id="status-indicator" style="display: none;">Status</div>

    <div id="image-modal" onclick="this.style.display='none'">
        <img id="modal-image-content" src="" alt="Full Image">
    </div>

    <aside id="sidebar" class="w-64 bg-[#2f3136] flex flex-col flex-shrink-0 h-full" style="display: none;">
        <div id="server-banner-container" style="display:none;">
             <img id="sidebar-server-icon" src="" alt="Icon">
             <div id="server-name-header">Haven Chat</div>
        </div>
        <div class="p-4 flex-grow overflow-y-auto"> <div class="flex items-center justify-between mb-3">
                 <h2 class="text-sm font-semibold text-gray-400 uppercase tracking-wider">Channels</h2>
                 <span id="username-display" class="text-xs text-gray-400">Not Logged In</span>
            </div>
            <nav id="channel-list" class="space-y-1 mb-4"></nav>
        </div>

        <div class="p-4 border-t border-gray-700/50"> <div id="sidebar-create-post-container" class="mb-3">
                <button id="sidebarCreatePostButton" class="w-full flex items-center justify-center space-x-2 bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2.5 px-4 rounded-lg transition-colors shadow-md text-sm">
                    <i class="fas fa-plus-circle"></i>
                    <span>New Global Post</span>
                </button>
                <div id="sidebarCreatePostUI" class="mt-3 hidden p-3 bg-gray-700/50 rounded-lg relative"> <textarea id="create-post-input" rows="3" maxlength="140" placeholder="What's happening globally? (Max 140 chars)" class="w-full p-2 rounded bg-gray-600 border border-gray-500 focus:border-indigo-500 text-sm mb-2"></textarea>
                    <div class="flex justify-end items-center">
                         <span id="create-post-char-count" class="text-xs text-gray-400 mr-3">0/140</span>
                         <button id="create-post-btn" class="text-sm bg-cyan-600 hover:bg-cyan-700 text-white py-1 px-3 rounded">Post</button>
                    </div>
                    <div id="create-post-status" class="text-xs mt-1 min-h-[1em]"></div>
                </div>
            </div>

            <button id="openSettingsModalButton" class="w-full flex items-center space-x-3 px-3 py-2.5 rounded-lg hover:bg-gray-700 transition-colors text-sm mb-2 text-gray-300 hover:text-white">
                <i class="fas fa-cog w-5 h-5"></i>
                <span>Settings & Admin</span>
            </button>

            <button id="logout-button" class="w-full flex items-center space-x-3 px-3 py-2.5 bg-red-600 hover:bg-red-700 text-white font-semibold rounded-lg text-sm">
                <i class="fas fa-sign-out-alt w-5 h-5"></i>
                <span>Logout</span>
            </button>
        </div>
    </aside>

    <main id="main-chat-area" class="flex-1 bg-[#36393f] flex h-full overflow-hidden" style="display: none;">
        <div id="center-content-area" class="flex-1 flex flex-col h-full overflow-hidden">
            <header class="bg-[#36393f] p-3 border-b border-gray-900 shadow-md flex-shrink-0 flex items-center">
                <button id="sidebar-toggle-btn" class="text-white mr-3 md:hidden"> <i class="fas fa-bars text-xl"></i> </button>
                 <span id="channel-header-icon" class="text-gray-400 text-xl mr-2"><i class="fas fa-hashtag"></i></span>
                 <h1 id="main-channel-name-header" class="text-xl font-semibold text-white truncate">_select_channel_</h1>
                 <span id="channel-readonly-indicator" class="ml-3 text-xs bg-yellow-600 text-white px-2 py-0.5 rounded-full flex-shrink-0" style="display:none;">Read-Only</span>
            </header>
            
            <div id="thread-list-container" class="flex-1 flex flex-col p-4 overflow-y-auto" style="display: none;"> <button id="create-new-thread-btn" class="mb-4 w-full py-2 px-4 rounded-md text-white font-semibold sticky top-0 bg-[#2f3136] z-10 shadow"> <i class="fas fa-plus-circle mr-2"></i>Create New Thread </button>
                 <div id="threads-display-area" class="flex-grow"></div>
            </div>
            <div id="thread-create-form-container" class="flex-1 p-4 overflow-y-auto" style="display: none;"> <button id="back-to-threads-from-create-btn" class="sticky-header-button"><i class="fas fa-arrow-left mr-1"></i> Back to Threads</button>
                 <h2 class="text-xl font-semibold my-3">Create New Thread in <span id="create-thread-channel-name" class="font-bold"></span></h2>
                 <input type="text" id="new-thread-title" placeholder="Thread Title (or Image Title for Imageboard)" class="w-full p-2 mb-3 rounded bg-[#202225] border border-[#202225] focus:border-[var(--theme-color-primary)] outline-none">
                 <div class="message-input-area mb-3 relative">
                     <textarea id="new-thread-op-message" placeholder="Your initial message/post (or Image URL for Imageboard)..." class="w-full p-2 rounded bg-[#202225] border border-[#202225] focus:border-[var(--theme-color-primary)] outline-none min-h-[120px]"></textarea>
                     <div id="thread-create-char-counter" class="text-xs text-gray-400 text-right pr-1 pt-1 absolute bottom-1 right-1" style="display: none;">0/0</div>
                 </div>
                 <button id="submit-new-thread-btn" class="w-full py-2 px-4 rounded-md text-white font-semibold">Post Thread</button>
            </div>
            <div id="single-thread-view-container" class="flex-1 flex flex-col overflow-hidden" style="display: none;"> <div id="thread-view-header" class="flex-shrink-0">
                     <button id="back-to-threads-btn" class="sticky-header-button"><i class="fas fa-arrow-left mr-1"></i> Back to <span id="back-to-threads-channel-name"></span></button>
                     <h2 id="single-thread-title-header" class="text-lg font-semibold inline-block ml-2">Thread Title</h2>
                 </div>
                 <div id="thread-op-message-container" class="overflow-y-auto p-4 flex-shrink-0"></div>
                 <div id="thread-replies-container" class="flex-grow p-4 space-y-2 overflow-y-auto"></div>
                 <div id="reply-form-container" class="mt-auto flex-shrink-0 p-3 border-t border-gray-700">
                     <div class="relative">
                         <textarea id="reply-message-input" placeholder="Write a reply..." class="w-full p-2 rounded bg-[#40444b] border border-[#202225] focus:border-[var(--theme-color-primary)] outline-none min-h-[60px]"></textarea>
                         <div id="reply-char-counter" class="text-xs text-gray-400 text-right pr-2 pb-1 absolute bottom-1 right-1" style="display: none;">0/0</div>
                     </div>
                     <button id="submit-reply-btn" class="mt-2 w-full py-2 px-4 rounded-md text-white font-semibold">Post Reply</button>
                 </div>
            </div>
            <div id="message-list-container" class="flex-1 p-4 overflow-y-auto space-y-1"></div> <footer id="general-message-footer" class="bg-[#40444b] rounded-lg flex-shrink-0 mt-auto mx-4 mb-3 shadow-md relative">
                 <div class="flex items-center p-2">
                    <div class="message-input-actions flex items-center mr-2 flex-shrink-0"> <button id="emoji-picker-button" title="Open Emoji Picker" class="mr-1" disabled><i class="fas fa-smile"></i></button>
                        <button id="sticker-picker-button" title="Open Sticker Picker" class="mr-1" disabled><i class="fas fa-sticky-note"></i></button>
                        <input type="file" id="file-upload-input" style="display: none;" accept="*/*">
                        <button id="file-upload-button" title="Send File (temp.sh)" disabled><i class="fas fa-paperclip"></i></button>
                    </div>
                    <div id="custom-input-area-wrapper" class="flex-grow min-w-0 mx-1"> <input type="text" id="general-message-input" placeholder="Message #channel..." class="w-full bg-transparent text-white placeholder-gray-500 focus:outline-none px-1 py-2 text-sm" aria-label="Message Input" disabled/>
                    </div>
                    <button id="general-send-button" class="ml-2 text-white font-semibold py-2 px-4 rounded-md flex-shrink-0" aria-label="Send Message" disabled>Send</button> </div>
                 <div id="general-char-counter" class="text-xs text-gray-400 text-right px-3 pb-1" style="display: none;">0/0</div>
                 
                 <div id="emoji-picker-panel" class="emoji-sticker-picker-panel-base" style="display: none;">
                    <p class="text-xs text-gray-400 col-span-full text-center">Load Grape Packs in Settings to see emojis.</p>
                 </div>
                 <div id="sticker-picker-panel" class="emoji-sticker-picker-panel-base" style="display: none;">
                    <p class="text-xs text-gray-400 col-span-full text-center">Load Grape Packs in Settings to see stickers.</p>
                 </div>
            </footer>
        </div>

        <aside id="right-sidebar" class="w-60 bg-[#2f3136] h-full flex flex-col flex-shrink-0 border-l border-gray-900/50 p-0 overflow-hidden">
            <div id="online-users-section" class="p-3 overflow-y-auto flex-shrink-0"> <h3 class="text-sm font-semibold text-gray-400 uppercase tracking-wider mb-2">Online Users</h3>
                 <div id="online-user-list" class="space-y-1">
                     <p class="text-xs text-gray-500">Loading...</p>
                 </div>
            </div>
            <div class="mt-auto flex-grow"></div> <div id="recent-posts-section" class="flex-shrink-0 border-t border-gray-700 p-3 overflow-y-auto" style="max-height: 40%;"> <h3 class="text-sm font-semibold text-gray-400 uppercase tracking-wider mb-2 flex-shrink-0">Recent Posts</h3>
                <div id="recent-posts-feed" class="space-y-3 pr-1">
                    <p class="text-xs text-gray-500">Loading...</p>
                </div>
            </div>
       </aside>
    </main>

    <div id="settingsModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 modal-transition modal-hidden z-50">
        <div class="bg-[#36393f] text-gray-200 rounded-lg shadow-xl w-full max-w-2xl transform modal-transition max-h-[90vh] flex flex-col">
            <div class="flex justify-between items-center p-5 border-b border-gray-700/50 rounded-t-lg flex-shrink-0">
                <h3 class="text-xl font-semibold">Settings & Admin</h3>
                <button id="closeSettingsModalButton" class="text-gray-400 hover:text-gray-300 transition-colors">
                    <i class="fas fa-times fa-lg"></i>
                </button>
            </div>

            <div class="p-6 overflow-y-auto flex-grow">
                <div class="border-b border-gray-700/50 mb-6">
                    <nav class="-mb-px flex space-x-8" aria-label="Tabs">
                        <button id="userSettingsTab" class="whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-transparent hover:border-gray-500 hover:text-gray-300 tab-active" data-tab="userSettingsContent">
                            User Settings
                        </button>
                        <button id="adminActionsTab" class="whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-transparent hover:border-gray-500 hover:text-gray-300" data-tab="adminActionsContent" style="display: none;">
                            Admin Actions
                        </button>
                    </nav>
                </div>

                <div id="userSettingsContent" class="tab-content space-y-6">
                    <div>
                        <h3 class="text-lg font-semibold text-gray-300 uppercase tracking-wider mb-3">Update Avatar</h3>
                        <div class="flex items-center mb-2">
                            <input type="text" id="avatar-url-input" placeholder="Image URL for new avatar" class="flex-1 text-sm p-2 rounded bg-gray-700 border border-gray-600 focus:border-indigo-500">
                            <button id="update-avatar-button" class="ml-2 text-sm bg-indigo-500 hover:bg-indigo-600 text-white py-2 px-3 rounded">Save Avatar</button>
                        </div>
                        <div id="avatar-update-status" class="text-xs min-h-[1em] mb-2"></div>
                        <div class="mt-2 flex items-center">
                            <span class="text-xs text-gray-400 mr-2">Current:</span>
                            <img id="current-user-avatar-preview" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="Current Avatar" class="w-10 h-10 rounded-full bg-gray-600 object-cover">
                        </div>
                    </div>
                    <hr class="border-gray-700/50">
                    <div>
                        <h3 class="text-lg font-semibold text-gray-300 uppercase tracking-wider mb-3">Grape Packs (Emoji/Stickers)</h3>
                        <div class="mb-3">
                            <label for="grape-pack-url-input" class="block text-sm font-medium text-gray-400 mb-1">Add Pack from URL (JSON):</label>
                            <div class="flex items-center">
                                <input type="text" id="grape-pack-url-input" placeholder="https://example.com/pack.json" class="flex-1 text-sm p-2 rounded-l bg-gray-700 border border-gray-600 focus:border-indigo-500">
                                <button id="add-grape-pack-url-btn" class="text-sm bg-green-600 hover:bg-green-700 text-white py-2 px-3 rounded-r">Add URL</button>
                            </div>
                        </div>
                        <div class="mb-3">
                            <label for="grape-pack-file-input" class="block text-sm font-medium text-gray-400 mb-1">Add Pack from File (JSON):</label>
                            <input type="file" id="grape-pack-file-input" accept=".json" class="text-sm p-2 rounded bg-gray-700 border border-gray-600 w-full">
                        </div>
                        <div id="grape-pack-load-status" class="text-xs min-h-[1em] mb-2"></div>
                        <h4 class="text-md font-semibold text-gray-300 mb-2">Loaded Grape Packs:</h4>
                        <div id="loaded-grape-packs-list" class="space-y-2 max-h-40 overflow-y-auto bg-gray-700/30 p-2 rounded">
                            <p class="text-xs text-gray-500">No packs loaded yet.</p>
                        </div>
                    </div>

                </div>

                <div id="adminActionsContent" class="tab-content hidden">
                    <h3 class="text-lg font-semibold text-gray-300 uppercase tracking-wider mb-3">Admin Tools</h3>
                    <div class="admin-input-group">
                        <label for="new-channel-name">Channel Name:</label>
                        <input type="text" id="new-channel-name" placeholder="e.g., cool-chat">
                    </div>
                    <div class="admin-input-group">
                        <label for="new-channel-type">Channel Type:</label>
                        <select id="new-channel-type">
                            <option value="chat" selected>Chat</option>
                            <option value="announcements">Announcements</option>
                            <option value="forum">Forum</option>
                            <option value="imageboard">Imageboard</option>
                        </select>
                    </div>
                    <div class="admin-input-group">
                        <label class="flex items-center">
                            <input type="checkbox" id="new-channel-writable" checked class="form-checkbox h-4 w-4 text-indigo-600 transition duration-150 ease-in-out bg-gray-700 border-gray-600 focus:ring-indigo-500">
                            <span class="ml-2 text-sm text-gray-300">Publicly Writable</span>
                        </label>
                        <p class="text-xs text-gray-500 mt-1">(Uncheck for read-only. Announcements type defaults to read-only.)</p>
                    </div>
                    <button id="create-channel-button" class="mt-3 w-full py-2 px-4 rounded-md text-white font-semibold bg-[var(--theme-color-primary)] hover:bg-[var(--theme-color-primary-hover)]">Create Channel</button>
                    <div id="admin-status" class="text-xs text-gray-400 mt-2 min-h-[1em]"></div>
                </div>
            </div>

            <div class="flex justify-end items-center p-5 border-t border-gray-700/50 rounded-b-lg space-x-3 flex-shrink-0">
                <button id="cancelSettingsModalButton" class="px-4 py-2 text-sm font-medium text-gray-300 bg-gray-600 hover:bg-gray-500 rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors">
                    Close
                </button>
            </div>
        </div>
    </div>


    <script>
        const SERVER_URL = 'https://concord.havensgaming.com'; // Ensure this is your correct server URL

        // DOM Elements (ensure all are correctly identified after HTML changes)
        const sidebarCreatePostButton = document.getElementById('sidebarCreatePostButton');
        const sidebarCreatePostUI = document.getElementById('sidebarCreatePostUI');
        const createPostInput = document.getElementById('create-post-input');
        const createPostBtn = document.getElementById('create-post-btn');
        const createPostStatus = document.getElementById('create-post-status');
        const createPostCharCount = document.getElementById('create-post-char-count');
        const recentPostsFeedDiv = document.getElementById('recent-posts-feed');
        const rightSidebar = document.getElementById('right-sidebar');
        const onlineUserListDiv = document.getElementById('online-user-list');
        const connectionFailedContainer = document.getElementById('connection-failed-container');
        const connectionFailedMessage = document.getElementById('connection-failed-message');
        const retryConnectionBtn = document.getElementById('retry-connection-btn');
        const authContainer = document.getElementById('auth-container');
        const authServerIcon = document.getElementById('auth-server-icon');
        const authServerName = document.getElementById('auth-server-name');
        const authTitle = document.getElementById('auth-title');
        const authErrorMessage = document.getElementById('auth-error-message');
        const usernameInput = document.getElementById('username-input');
        const passwordInput = document.getElementById('password-input');
        const authButton = document.getElementById('auth-button');
        const toggleAuthMode = document.getElementById('toggle-auth-mode');
        const sidebar = document.getElementById('sidebar');
        const sidebarToggleBtn = document.getElementById('sidebar-toggle-btn');
        const serverBannerContainer = document.getElementById('server-banner-container');
        const sidebarServerIcon = document.getElementById('sidebar-server-icon');
        const serverNameHeader = document.getElementById('server-name-header');
        const mainChatArea = document.getElementById('main-chat-area');
        const usernameDisplay = document.getElementById('username-display');
        const channelListElement = document.getElementById('channel-list');
        const logoutButton = document.getElementById('logout-button');
        const mainChannelNameHeaderDOM = document.getElementById('main-channel-name-header');
        const mainChannelHeaderIconDOM = document.getElementById('channel-header-icon');
        const channelReadonlyIndicator = document.getElementById('channel-readonly-indicator');
        const statusIndicator = document.getElementById('status-indicator');
        const messageListContainerDOM = document.getElementById('message-list-container');
        const threadListContainerDOM = document.getElementById('thread-list-container');
        const threadsDisplayArea = document.getElementById('threads-display-area');
        const createNewThreadBtn = document.getElementById('create-new-thread-btn');
        const threadCreateFormContainerDOM = document.getElementById('thread-create-form-container');
        const createThreadChannelNameSpan = document.getElementById('create-thread-channel-name');
        const backToThreadsFromCreateBtn = document.getElementById('back-to-threads-from-create-btn');
        const newThreadTitleInput = document.getElementById('new-thread-title');
        const newThreadOpMessageTextarea = document.getElementById('new-thread-op-message');
        const threadCreateCharCounter = document.getElementById('thread-create-char-counter');
        const submitNewThreadBtn = document.getElementById('submit-new-thread-btn');
        const singleThreadViewContainerDOM = document.getElementById('single-thread-view-container');
        const singleThreadTitleHeader = document.getElementById('single-thread-title-header');
        const backToThreadsBtn = document.getElementById('back-to-threads-btn');
        const backToThreadsChannelNameSpan = document.getElementById('back-to-threads-channel-name');
        const threadOpMessageContainer = document.getElementById('thread-op-message-container');
        const threadRepliesContainer = document.getElementById('thread-replies-container');
        const replyFormContainer = document.getElementById('reply-form-container');
        const replyMessageInput = document.getElementById('reply-message-input');
        const replyCharCounter = document.getElementById('reply-char-counter');
        const submitReplyBtn = document.getElementById('submit-reply-btn');
        const generalMessageFooter = document.getElementById('general-message-footer');
        const customInputAreaWrapper = document.getElementById('custom-input-area-wrapper');
        const generalMessageInput = document.getElementById('general-message-input');
        const generalSendButton = document.getElementById('general-send-button');
        const generalCharCounter = document.getElementById('general-char-counter');
        const openSettingsModalButton = document.getElementById('openSettingsModalButton');
        const settingsModal = document.getElementById('settingsModal');
        const closeSettingsModalButton = document.getElementById('closeSettingsModalButton');
        const cancelSettingsModalButton = document.getElementById('cancelSettingsModalButton');
        const userSettingsTab = document.getElementById('userSettingsTab');
        const adminActionsTab = document.getElementById('adminActionsTab');
        const userSettingsContent = document.getElementById('userSettingsContent');
        const adminActionsContent = document.getElementById('adminActionsContent');
        const avatarUrlInput = document.getElementById('avatar-url-input');
        const updateAvatarButton = document.getElementById('update-avatar-button');
        const avatarUpdateStatus = document.getElementById('avatar-update-status');
        const currentUserAvatarPreview = document.getElementById('current-user-avatar-preview');
        const newChannelNameInput = document.getElementById('new-channel-name');
        const newChannelTypeSelect = document.getElementById('new-channel-type');
        const newChannelWritableCheckbox = document.getElementById('new-channel-writable');
        const createChannelButton = document.getElementById('create-channel-button');
        const adminStatus = document.getElementById('admin-status');
        const imageModal = document.getElementById('image-modal');
        const modalImageContent = document.getElementById('modal-image-content');
        const grapePackUrlInput = document.getElementById('grape-pack-url-input');
        const addGrapePackUrlBtn = document.getElementById('add-grape-pack-url-btn');
        const grapePackFileInput = document.getElementById('grape-pack-file-input');
        const grapePackLoadStatus = document.getElementById('grape-pack-load-status');
        const loadedGrapePacksList = document.getElementById('loaded-grape-packs-list');
        const fileUploadInput = document.getElementById('file-upload-input');
        const fileUploadButton = document.getElementById('file-upload-button');
        const emojiPickerButton = document.getElementById('emoji-picker-button'); 
        const stickerPickerButton = document.getElementById('sticker-picker-button');
        const emojiPickerPanel = document.getElementById('emoji-picker-panel');
        const stickerPickerPanel = document.getElementById('sticker-picker-panel');


        // Global state variables
        let currentChannelData = null;
        let socket;
        let currentUserData = null;
        let isRegisterMode = false;
        let allChannelsCache = [];
        let defaultChannelNameFromServer = 'general';
        let currentServerConfig = {};
        let currentViewedThreadId = null;
        let currentViewedThreadTitle = "";
        let currentView = 'chat';
        let isProcessingAuth = false;
        let loadedGrapePacks = []; 

        // --- Grape Pack Logic ---
        function saveGrapePacksToStorage() {
            try { localStorage.setItem('grapePacks', JSON.stringify(loadedGrapePacks)); }
            catch (e) { console.error("Error saving Grape Packs:", e); showStatus("Could not save Grape Packs.", "error"); }
        }

        function loadGrapePacksFromStorage() {
            const storedPacks = localStorage.getItem('grapePacks');
            if (storedPacks) { try { loadedGrapePacks = JSON.parse(storedPacks); } catch (e) { console.error("Error parsing Grape Packs:", e); loadedGrapePacks = []; } }
            renderLoadedGrapePacksList(); renderEmojiPicker(); renderStickerPicker();
        }

        function renderLoadedGrapePacksList() {
            if (!loadedGrapePacksList) return; loadedGrapePacksList.innerHTML = '';
            if (loadedGrapePacks.length === 0) { loadedGrapePacksList.innerHTML = '<p class="text-xs text-gray-500">No packs loaded.</p>'; return; }
            loadedGrapePacks.forEach((pack, index) => {
                const item = document.createElement('div'); item.className = 'grape-pack-item text-sm';
                item.innerHTML = `<span>${escapeHTML(pack.packName)}</span><button class="remove-grape-pack-btn" data-index="${index}">Remove</button>`;
                loadedGrapePacksList.appendChild(item);
            });
        }

        function addPackToLoadedList(packData) {
            if (!packData || typeof packData.packName !== 'string' || (packData.emojis && typeof packData.emojis !== 'object') || (packData.stickers && typeof packData.stickers !== 'object')) {
                if(grapePackLoadStatus) grapePackLoadStatus.textContent = 'Invalid Pack structure.'; showStatus('Invalid Pack structure.', 'error'); return false;
            }
            packData.emojis = packData.emojis || {}; packData.stickers = packData.stickers || {};
            if (loadedGrapePacks.some(p => p.packName === packData.packName)) {
                if(grapePackLoadStatus) grapePackLoadStatus.textContent = `Pack "${packData.packName}" already loaded.`; showStatus(`Pack "${packData.packName}" already loaded.`, 'info'); return false;
            }
            loadedGrapePacks.push(packData); saveGrapePacksToStorage(); renderLoadedGrapePacksList(); renderEmojiPicker(); renderStickerPicker();
            if(grapePackLoadStatus) grapePackLoadStatus.textContent = `Pack "${packData.packName}" added!`; showStatus(`Pack "${packData.packName}" added!`, 'success'); return true;
        }

        async function handleAddGrapePackByUrl() {
            if (!grapePackUrlInput || !grapePackUrlInput.value) return; const url = grapePackUrlInput.value.trim(); if (!url) return;
            if(grapePackLoadStatus) grapePackLoadStatus.textContent = 'Loading...';
            try { const response = await fetch(url); if (!response.ok) throw new Error(`Workspace failed: ${response.status}`);
                const data = await response.json(); addPackToLoadedList(data); grapePackUrlInput.value = '';
            } catch (error) { console.error("Error loading pack URL:", error); if(grapePackLoadStatus) grapePackLoadStatus.textContent = `Error: ${error.message}`; showStatus(`Error loading pack: ${error.message}`, 'error');}
        }

        function handleAddGrapePackFromFile(event) {
            const file = event.target.files[0]; if (!file) return; if(grapePackLoadStatus) grapePackLoadStatus.textContent = 'Loading...';
            const reader = new FileReader();
            reader.onload = (e) => { try { const data = JSON.parse(e.target.result); addPackToLoadedList(data); } catch (error) { console.error("Error parsing pack file:", error); if(grapePackLoadStatus) grapePackLoadStatus.textContent = `Error: ${error.message}`; showStatus(`Error parsing pack: ${error.message}`, 'error');}};
            reader.readAsText(file); if(grapePackFileInput) grapePackFileInput.value = ''; 
        }

        function handleRemoveGrapePack(event) {
            if (event.target.classList.contains('remove-grape-pack-btn')) {
                const index = parseInt(event.target.dataset.index, 10);
                if (!isNaN(index) && index >= 0 && index < loadedGrapePacks.length) {
                    const name = loadedGrapePacks[index].packName; loadedGrapePacks.splice(index, 1);
                    saveGrapePacksToStorage(); renderLoadedGrapePacksList(); renderEmojiPicker(); renderStickerPicker();
                    if(grapePackLoadStatus) grapePackLoadStatus.textContent = `Pack "${name}" removed.`; showStatus(`Pack "${name}" removed.`, 'info');
                }
            }
        }
        
        function renderEmojiPicker() {
            if (!emojiPickerPanel) return; emojiPickerPanel.innerHTML = ''; let hasEmojis = false;
            loadedGrapePacks.forEach(pack => {
                if (pack.emojis) {
                    for (const name in pack.emojis) {
                        hasEmojis = true; const url = pack.emojis[name];
                        const item = document.createElement('div'); item.className = 'picker-item'; item.title = `${escapeHTML(name)}`;
                        item.dataset.itemUrl = url; item.dataset.itemType = 'emoji';
                        const img = document.createElement('img'); img.src = escapeHTML(url); img.alt = escapeHTML(name); img.className = 'picker-emoji';
                        img.onerror = function() { this.src = 'https://placehold.co/32x32/72767d/FFFFFF?text=X'; this.alt='Error';};
                        item.appendChild(img); item.addEventListener('click', handlePickerItemClick); emojiPickerPanel.appendChild(item);
                    }
                }
            });
            if (!hasEmojis) emojiPickerPanel.innerHTML = '<p class="text-xs text-gray-400 col-span-full text-center">No emojis loaded.</p>';
        }

        function renderStickerPicker() {
            if (!stickerPickerPanel) return; stickerPickerPanel.innerHTML = ''; let hasStickers = false;
            loadedGrapePacks.forEach(pack => {
                if (pack.stickers) {
                    for (const name in pack.stickers) {
                        hasStickers = true; const url = pack.stickers[name];
                        const item = document.createElement('div'); item.className = 'picker-item'; item.title = `${escapeHTML(name)}`;
                        item.dataset.itemUrl = url; item.dataset.itemType = 'sticker';
                        const img = document.createElement('img'); img.src = escapeHTML(url); img.alt = escapeHTML(name); img.className = 'picker-sticker';
                        img.onerror = function() { this.src = 'https://placehold.co/48x48/72767d/FFFFFF?text=X'; this.alt='Error';};
                        item.appendChild(img); item.addEventListener('click', handlePickerItemClick); stickerPickerPanel.appendChild(item);
                    }
                }
            });
            if (!hasStickers) stickerPickerPanel.innerHTML = '<p class="text-xs text-gray-400 col-span-full text-center">No stickers loaded.</p>';
        }

        function toggleEmojiPicker() {
            if (!emojiPickerPanel || !stickerPickerPanel) return;
            const isVisible = emojiPickerPanel.style.display === 'grid';
            stickerPickerPanel.style.display = 'none'; 
            emojiPickerPanel.style.display = isVisible ? 'none' : 'grid';
            if (!isVisible) renderEmojiPicker();
        }

        function toggleStickerPicker() {
            if (!stickerPickerPanel || !emojiPickerPanel) return;
            const isVisible = stickerPickerPanel.style.display === 'grid';
            emojiPickerPanel.style.display = 'none'; 
            stickerPickerPanel.style.display = isVisible ? 'none' : 'grid';
            if (!isVisible) renderStickerPicker();
        }
        
        function handlePickerItemClick(event) {
            const itemDiv = event.currentTarget; const url = itemDiv.dataset.itemUrl; const type = itemDiv.dataset.itemType;
            if (!url || !type) return;
            if (type === 'emoji') {
                if (generalMessageInput) {
                    const currentVal = generalMessageInput.value; const start = generalMessageInput.selectionStart; const end = generalMessageInput.selectionEnd;
                    const textToInsert = `emoji:${url}`;
                    generalMessageInput.value = currentVal.substring(0, start) + textToInsert + currentVal.substring(end);
                    generalMessageInput.focus(); generalMessageInput.setSelectionRange(start + textToInsert.length, start + textToInsert.length);
                    toggleEmojiPicker(); 
                } else { showStatus("Input field not found.", "error"); }
            } else if (type === 'sticker') {
                if (socket && socket.connected && currentChannelData) {
                    socket.emit('sendMessage', { text: `sticker:${url}`, channel: currentChannelData.name });
                    toggleStickerPicker(); 
                } else { showStatus("Cannot send sticker.", "error"); }
            }
        }

        async function handleFileUpload(event) {
            const file = event.target.files[0]; if (!file) return;
            if (!socket || !socket.connected || !currentChannelData) { showStatus("Cannot send file.", "error"); if(fileUploadInput) fileUploadInput.value = ''; return; }
            showStatus(`Uploading ${escapeHTML(file.name)}...`, 'info', 0); 
            const formData = new FormData(); formData.append('file', file); 
            try {
                const response = await fetch('https://temp.sh/upload', { method: 'POST', body: formData });
                if (!response.ok) { const errText = await response.text(); throw new Error(`Upload failed: ${response.status}. ${errText}`); }
                const fileUrl = await response.text(); 
                socket.emit('sendMessage', { text: fileUrl.trim(), channel: currentChannelData.name });
                showStatus(`File sent: ${escapeHTML(fileUrl.trim())}`, 'success');
            } catch (error) { console.error("File upload error:", error); showStatus(`Error uploading: ${error.message}`, 'error'); }
            finally { if(fileUploadInput) fileUploadInput.value = ''; }
        }

        function openSettingsPopup() { /* ... (content mostly unchanged, ensure it doesn't error) ... */ 
            if (!settingsModal) return;
            settingsModal.classList.remove('modal-hidden'); settingsModal.classList.add('modal-visible');
            if (currentUserData) {
                if (currentUserAvatarPreview) currentUserAvatarPreview.src = currentUserData.avatarUrl || 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
                if (avatarUrlInput) avatarUrlInput.value = currentUserData.avatarUrl || '';
                if (avatarUpdateStatus) avatarUpdateStatus.textContent = '';
                if (adminActionsTab) adminActionsTab.style.display = (currentUserData.roles?.includes('admin')) ? 'inline-block' : 'none';
            }
            renderLoadedGrapePacksList(); if(grapePackLoadStatus) grapePackLoadStatus.textContent = ''; 
            switchSettingsTab(userSettingsTab); if(closeSettingsModalButton) closeSettingsModalButton.focus();
        }
        function closeSettingsPopup() { /* ... (content mostly unchanged) ... */ 
            if (!settingsModal) return;
            settingsModal.classList.add('modal-hidden'); settingsModal.classList.remove('modal-visible');
            if (openSettingsModalButton) openSettingsModalButton.focus();
        }
        function switchSettingsTab(selectedTab) { /* ... (content mostly unchanged) ... */ 
            if (!userSettingsTab || !adminActionsTab || !userSettingsContent || !adminActionsContent || !selectedTab) return;
            [userSettingsTab, adminActionsTab].forEach(tab => { if(tab) {tab.classList.remove('tab-active'); tab.classList.add('border-transparent');}});
            selectedTab.classList.add('tab-active'); selectedTab.classList.remove('border-transparent');
            [userSettingsContent, adminActionsContent].forEach(content => { if(content) content.classList.add('hidden'); });
            const activeContent = document.getElementById(selectedTab.dataset.tab);
            if (activeContent) activeContent.classList.remove('hidden');
        }

        function showStatus(message, type = 'info', duration = 3000) { /* ... (content unchanged) ... */ 
            if (!statusIndicator) return; statusIndicator.textContent = message;
            statusIndicator.className = 'fixed bottom-5 right-5 p-3 rounded shadow-lg text-white z-[1001]'; 
            if (type === 'error') statusIndicator.classList.add('bg-red-500');
            else if (type === 'success') statusIndicator.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--theme-color-primary');
            else statusIndicator.classList.add('bg-blue-500');
            statusIndicator.style.display = 'block';
            if (statusIndicator.timeoutId) clearTimeout(statusIndicator.timeoutId);
            if (duration > 0) statusIndicator.timeoutId = setTimeout(() => { statusIndicator.style.display = 'none'; statusIndicator.style.backgroundColor = '';}, duration);
        }
        function escapeHTML(str) { /* ... (content unchanged) ... */ 
            if (typeof str !== 'string') return ''; const d = document.createElement('div'); d.appendChild(document.createTextNode(str)); return d.innerHTML;
        }
        function openImageModal(imageUrl) { /* ... (content unchanged) ... */ 
            if (imageModal && modalImageContent) { modalImageContent.src = imageUrl; imageModal.style.display = 'flex'; }
        }
        function lightenDarkenColor(col, amt) { /* ... (content unchanged) ... */ 
            let usePound = false; if (col && col[0] === "#") { col = col.slice(1); usePound = true; } else if (!col) return "#000000";
            const num = parseInt(col, 16); if (isNaN(num)) return usePound ? "#000000" : "000000";
            let r = (num >> 16) + amt; if (r > 255) r = 255; else if (r < 0) r = 0;
            let g = ((num >> 8) & 0x00FF) + amt; if (g > 255) g = 255; else if (g < 0) g = 0;
            let b = (num & 0x0000FF) + amt; if (b > 255) b = 255; else if (b < 0) b = 0;
            const toHex = c => c.toString(16).padStart(2, '0'); return (usePound?"#":"") + toHex(r) + toHex(g) + toHex(b);
        }
        function parseAndRenderMessageText(text, channelType, isOpMessage = false) { /* ... (content largely unchanged, ensure it handles emoji: and sticker: first) ... */ 
            let processedText = text;
            if (processedText.startsWith('emoji:')) { const url = processedText.substring(6); return `<img src="${escapeHTML(url)}" alt="emoji" class="inline-emoji" onerror="this.style.display='none';">`; }
            if (processedText.startsWith('sticker:')) { const url = processedText.substring(8); return `<img src="${escapeHTML(url)}" alt="sticker" class="chat-sticker" onerror="this.style.display='none';">`; }
            // ... rest of the image/video/link parsing
            const replacements = []; 
            const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/|v\/|shorts\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})(?:\S+)?/gi;
            let match; let tempTextForYoutube = processedText;
            while ((match = youtubeRegex.exec(tempTextForYoutube)) !== null) {
                replacements.push({ original: match[0], replacement: `<div class="video-embed-container my-2"><iframe src="https://www.youtube.com/embed/${match[1]}" frameborder="0" allowfullscreen class="w-full aspect-video rounded-lg"></iframe></div>` });
            }
            const videoFileRegex = /(https?:\/\/[^\s]+?\.(?:mp4|webm|ogg))(?!["'])/gi;
            let tempTextForVideoFile = processedText;
            while ((match = videoFileRegex.exec(tempTextForVideoFile)) !== null) {
                if (!replacements.some(r=>r.original.includes(match[0])||match[0].includes(r.original))) replacements.push({ original: match[0], replacement: `<div class="video-embed-container my-2"><video controls src="${escapeHTML(match[0])}" class="w-full aspect-video rounded-lg"></video></div>` });
            }
            replacements.sort((a, b) => b.original.length - a.original.length);
            let processedHtmlSegments = [processedText];
            replacements.forEach(rep => { let newSegments = []; processedHtmlSegments.forEach(segment => { if (typeof segment === 'string') { const parts = segment.split(rep.original); for (let i = 0; i < parts.length; i++) { newSegments.push(parts[i]); if (i < parts.length - 1) newSegments.push({ html: rep.replacement }); } } else newSegments.push(segment); }); processedHtmlSegments = newSegments; });
            let finalHtmlOutput = ""; const imageUrlRegex = /(https?:\/\/[^\s]+?\.(?:png|jpe?g|gif|webp|bmp|svg))(?!["'])/gi; const genericUrlRegex = /(https?:\/\/[^\s<]+[^\s<.)])/g; 
            processedHtmlSegments.forEach(segment => {
                if (typeof segment === 'string') { let textSegment = escapeHTML(segment);
                    textSegment = textSegment.replace(imageUrlRegex, (url) => `<img src="${url}" alt="image" class="rendered-image my-1" onclick="openImageModal(this.src)" onerror="this.src='https://placehold.co/300x200?text=Error'; this.alt='Error';">`);
                    textSegment = textSegment.replace(genericUrlRegex, (url) => { if (url.includes('src="')||url.includes('href="')) return url; let dUrl = url; if (url.startsWith('https://temp.sh/')) return `<a href="${escapeHTML(url)}" target="_blank" rel="noopener noreferrer" class="file-link temp-sh-link"><i class="fas fa-file-alt"></i> ${escapeHTML(dUrl)}</a>`; return `<a href="${escapeHTML(url)}" target="_blank" rel="noopener noreferrer" class="text-link">${escapeHTML(dUrl)}</a>`; });
                    finalHtmlOutput += textSegment;
                } else if (segment && segment.html) finalHtmlOutput += segment.html;
            });
            if (channelType === 'announcements' || (channelType === 'forum' && isOpMessage)) { marked.setOptions({ breaks: true, gfm: true, sanitize: false }); finalHtmlOutput = marked.parse(finalHtmlOutput); }
            return finalHtmlOutput;
        }

        function updateAuthUI() { /* ... (content unchanged) ... */ 
            if (!authTitle || !authButton || !toggleAuthMode || !authErrorMessage) return;
            if (isRegisterMode) { authTitle.textContent = 'Register'; authButton.textContent = 'Register'; toggleAuthMode.textContent = 'Login'; }
            else { authTitle.textContent = 'Login'; authButton.textContent = 'Login'; toggleAuthMode.textContent = 'Register'; }
            authErrorMessage.style.display = 'none';
        }
        function showChatUI(userData) { /* ... (content unchanged, ensure picker buttons enabled) ... */ 
            if(!authContainer || !connectionFailedContainer || !sidebar || !mainChatArea || !serverBannerContainer || !usernameDisplay) return;
            authContainer.style.display = 'none'; connectionFailedContainer.style.display = 'none';
            sidebar.style.display = 'flex'; mainChatArea.style.display = 'flex';
            serverBannerContainer.style.display = (currentServerConfig.serverBannerUrl || currentServerConfig.serverIconUrl) ? 'flex' : 'none';
            usernameDisplay.textContent = `Logged in as: ${escapeHTML(userData.username)}`;
            if (fileUploadButton) fileUploadButton.disabled = false;
            if (emojiPickerButton) emojiPickerButton.disabled = false; 
            if (stickerPickerButton) stickerPickerButton.disabled = false;
        }
        function showAuthScreen() { /* ... (content unchanged, ensure pickers hidden) ... */ 
            if(!connectionFailedContainer || !sidebar || !mainChatArea || !serverBannerContainer || !authContainer || !authServerName || !authServerIcon || !usernameInput || !passwordInput || !authButton) return;
            connectionFailedContainer.style.display = 'none'; sidebar.style.display = 'none'; mainChatArea.style.display = 'none'; serverBannerContainer.style.display = 'none';
            if (settingsModal && settingsModal.classList.contains('modal-visible')) closeSettingsPopup();
            authContainer.style.display = 'flex'; authServerName.textContent = currentServerConfig.serverName || "Haven Chat";
            if (currentServerConfig.serverIconUrl) { authServerIcon.src = currentServerConfig.serverIconUrl; authServerIcon.style.display = 'block'; } else { authServerIcon.style.display = 'none'; }
            updateAuthUI(); usernameInput.value = ''; passwordInput.value = '';
            authButton.disabled = !socket || !socket.connected;
            if (fileUploadButton) fileUploadButton.disabled = true; if (emojiPickerButton) emojiPickerButton.disabled = true; if (stickerPickerButton) stickerPickerButton.disabled = true;
            if (emojiPickerPanel) emojiPickerPanel.style.display = 'none'; if (stickerPickerPanel) stickerPickerPanel.style.display = 'none';
        }
        function showConnectionFailedScreen(message = "Couldn't connect...") { /* ... (content unchanged, ensure pickers hidden) ... */ 
            if(!authContainer || !sidebar || !mainChatArea || !serverBannerContainer || !connectionFailedMessage || !connectionFailedContainer || !statusIndicator) return;
            authContainer.style.display = 'none'; sidebar.style.display = 'none'; mainChatArea.style.display = 'none'; serverBannerContainer.style.display = 'none';
            if (settingsModal && settingsModal.classList.contains('modal-visible')) closeSettingsPopup();
            connectionFailedMessage.textContent = message; connectionFailedContainer.style.display = 'flex';
            statusIndicator.style.display = 'block'; statusIndicator.textContent = message; statusIndicator.className = 'fixed bottom-5 right-5 p-3 rounded shadow-lg text-white z-[1001] bg-red-500';
            if (fileUploadButton) fileUploadButton.disabled = true; if (emojiPickerButton) emojiPickerButton.disabled = true; if (stickerPickerButton) stickerPickerButton.disabled = true;
            if (emojiPickerPanel) emojiPickerPanel.style.display = 'none'; if (stickerPickerPanel) stickerPickerPanel.style.display = 'none';
        }
        function getChannelIconClass(channelType) { /* ... (content unchanged) ... */ 
            switch (channelType) { case 'announcements': return 'fa-bullhorn'; case 'forum': return 'fa-comments'; case 'imageboard': return 'fa-image'; default: return 'fa-hashtag'; }
        }
        function populateChannelList(channelsData) { /* ... (content unchanged) ... */ 
            if(!channelListElement) return; allChannelsCache = channelsData; channelListElement.innerHTML = '';
            if (!channelsData || channelsData.length === 0) { channelListElement.innerHTML = '<p class="text-xs text-gray-500 p-2">No channels.</p>'; return; }
            channelsData.forEach(ch => { const item = document.createElement('a'); item.href = '#'; item.classList.add('channel-item'); item.dataset.channelName = ch.name; if (currentChannelData?.name === ch.name) item.classList.add('active'); const icon = getChannelIconClass(ch.type); let delBtn = ''; if (currentUserData?.roles.includes('admin') && !ch.isDefault) { delBtn = `<button class="delete-channel-btn" data-channel-to-delete="${escapeHTML(ch.name)}">×</button>`; } item.innerHTML = `<span class="channel-item-name-group"><span class="channel-icon"><i class="fas ${icon}"></i></span><span>${escapeHTML(ch.name)}</span></span>${delBtn}`; channelListElement.appendChild(item); });
        }

        // MODIFIED: Add message to DOM - ensure scroll to bottom happens
        function addMessageToDOM(messageData, containerElement, isOpMessage = false, isReply = false) {
            if (!containerElement || !messageData || typeof messageData.text === 'undefined' || typeof messageData.sender === 'undefined') return;
            const messageElement = document.createElement('div'); messageElement.classList.add('message');
            if (isOpMessage) messageElement.classList.add('op-message'); if (isReply) messageElement.classList.add('reply-message');
            messageElement.dataset.messageId = messageData.messageId;
            const channelType = currentChannelData?.type || 'chat';
            const renderedText = parseAndRenderMessageText(messageData.text, channelType, isOpMessage);
            const avatarBg = messageData.avatarBg || (isOpMessage ? 'bg-green-600' : (isReply ? 'bg-purple-600' : 'bg-indigo-500'));
            const time = messageData.timestamp ? new Date(messageData.timestamp).toLocaleTimeString([], { hour:'2-digit', minute:'2-digit'}) : '';
            let delBtn = ''; if (currentUserData?.roles.includes('admin')) { const threadId = (isOpMessage || isReply) ? currentViewedThreadId : null; delBtn = `<button class="delete-message-btn" data-message-id="${messageData.messageId}" ${threadId ? `data-thread-id="${threadId}"` : ''}>×</button>`; }
            let avatarHTML = messageData.avatarUrl ? `<img src="${escapeHTML(messageData.avatarUrl)}" alt="avatar" onerror="this.style.display='none'; this.nextSibling.style.display='flex';"> <span class="w-full h-full flex items-center justify-center" style="display:none;">${escapeHTML(messageData.sender.substring(0,1).toUpperCase())}</span>` : escapeHTML(messageData.sender.substring(0, 1).toUpperCase());
            messageElement.innerHTML = `<div class="message-avatar ${avatarBg}">${avatarHTML}</div><div class="message-content"><div class="flex items-baseline"><span class="message-sender">${escapeHTML(messageData.sender)}</span><span class="message-timestamp">${time}</span>${delBtn}</div><div class="message-text">${renderedText}</div></div>`;
            containerElement.appendChild(messageElement);
            // Ensure scroll to bottom
            containerElement.scrollTop = containerElement.scrollHeight;
        }

        function applyServerConfig(config) { /* ... (content unchanged) ... */ 
            if (!config) { currentServerConfig = {}; return; } currentServerConfig = config; document.title = config.pageTitle || "Chat";
            if(authServerName) authServerName.textContent = config.serverName || "Chat"; if(authServerIcon) { if (config.serverIconUrl) { authServerIcon.src = config.serverIconUrl; authServerIcon.style.display = 'block'; } else { authServerIcon.style.display = 'none'; } }
            if(serverNameHeader) serverNameHeader.textContent = config.serverName || "Chat"; if(sidebarServerIcon) { if (config.serverIconUrl) { sidebarServerIcon.src = config.serverIconUrl; sidebarServerIcon.style.display = 'block'; } else { sidebarServerIcon.style.display = 'none'; } }
            if(serverBannerContainer) { if (config.serverBannerUrl) { serverBannerContainer.style.backgroundImage = `url('${escapeHTML(config.serverBannerUrl)}')`; serverBannerContainer.style.display = 'flex'; } else if (config.serverIconUrl) { serverBannerContainer.style.backgroundImage = 'none'; serverBannerContainer.style.display = 'flex'; } else { serverBannerContainer.style.display = 'none'; } }
            const themeColor = config.themeColor || '#5865f2'; const hoverColor = lightenDarkenColor(themeColor, -20); document.documentElement.style.setProperty('--theme-color-primary', themeColor); document.documentElement.style.setProperty('--theme-color-primary-hover', hoverColor);
        }
        function updateCharCounter(input, counter, limit) { /* ... (content unchanged) ... */ 
            if (!input || !counter) return; const len = input.value.length;
            if (limit && limit > 0) { counter.textContent = `${len}/${limit}`; counter.style.display = 'block'; counter.classList.toggle('limit-exceeded', len > limit); } 
            else counter.style.display = 'none';
        }

        // MODIFIED: showView to ensure message list scrolls to bottom when chat view is activated
        function showView(viewName) {
            if(!messageListContainerDOM || !threadListContainerDOM || !singleThreadViewContainerDOM || !threadCreateFormContainerDOM || !generalMessageFooter || !replyFormContainer || !mainChannelNameHeaderDOM || !mainChannelHeaderIconDOM) return;
            [messageListContainerDOM, threadListContainerDOM, singleThreadViewContainerDOM, threadCreateFormContainerDOM, generalMessageFooter, replyFormContainer].forEach(el => el.style.display = 'none');
            if (!currentChannelData) { mainChannelNameHeaderDOM.textContent = "_select_channel_"; mainChannelHeaderIconDOM.innerHTML = `<i class="fas fa-question-circle"></i>`; currentView = 'none'; return; }
            mainChannelNameHeaderDOM.textContent = currentChannelData.name; mainChannelHeaderIconDOM.innerHTML = `<i class="fas ${getChannelIconClass(currentChannelData.type)}"></i>`; currentView = viewName;
            switch (viewName) {
                case 'chat': 
                    messageListContainerDOM.style.display = 'block'; 
                    generalMessageFooter.style.display = 'flex'; 
                    if(channelReadonlyIndicator) channelReadonlyIndicator.style.display = currentChannelData.canWrite ? 'none' : 'inline-block'; 
                    if (currentChannelData.type === 'imageboard') generalMessageFooter.style.display = 'none';
                    // Scroll to bottom when switching to chat view
                    setTimeout(() => { messageListContainerDOM.scrollTop = messageListContainerDOM.scrollHeight; }, 0);
                    break;
                case 'threads': /* ... (content unchanged) ... */ 
                    threadListContainerDOM.style.display = 'flex'; if(createNewThreadBtn) createNewThreadBtn.style.display = currentChannelData.canWrite ? 'block' : 'none'; 
                    if(channelReadonlyIndicator) channelReadonlyIndicator.style.display = 'none';
                    if(createNewThreadBtn && newThreadOpMessageTextarea && newThreadTitleInput) {
                        const placeholder = currentChannelData.type === 'imageboard' ? "Image URL..." : "Initial message...";
                        const btnText = currentChannelData.type === 'imageboard' ? "New Image Post" : "New Thread";
                        createNewThreadBtn.innerHTML = `<i class="fas fa-plus-circle mr-2"></i>${btnText}`;
                        newThreadOpMessageTextarea.placeholder = placeholder;
                        newThreadTitleInput.placeholder = currentChannelData.type === 'imageboard' ? "Image Title" : "Thread Title";
                    }
                    break;
                case 'singleThread': /* ... (content unchanged, ensure replies scroll) ... */ 
                    singleThreadViewContainerDOM.style.display = 'flex'; replyFormContainer.style.display = 'block'; 
                    mainChannelNameHeaderDOM.textContent = currentViewedThreadTitle || "Thread"; 
                    if(channelReadonlyIndicator) channelReadonlyIndicator.style.display = 'none';
                    setTimeout(() => { if(threadRepliesContainer) threadRepliesContainer.scrollTop = threadRepliesContainer.scrollHeight; }, 0);
                    break;
                case 'createThread': /* ... (content unchanged) ... */ 
                    threadCreateFormContainerDOM.style.display = 'block'; 
                    if(createThreadChannelNameSpan) createThreadChannelNameSpan.textContent = currentChannelData.name;
                    mainChannelNameHeaderDOM.textContent = `New Post in ${currentChannelData.name}`;
                    if(channelReadonlyIndicator) channelReadonlyIndicator.style.display = 'none';
                    if(newThreadTitleInput) newThreadTitleInput.value = ''; if(newThreadOpMessageTextarea) newThreadOpMessageTextarea.value = '';
                    updateCharCounter(newThreadOpMessageTextarea, threadCreateCharCounter, currentChannelData.messageCharLimit);
                    const opPlaceholder = currentChannelData.type === 'imageboard' ? "Direct Image URL..." : "Your initial message/post...";
                    if(newThreadOpMessageTextarea) newThreadOpMessageTextarea.placeholder = opPlaceholder;
                    break;
                default: messageListContainerDOM.style.display = 'block'; messageListContainerDOM.innerHTML = '<p class="text-center p-4">Select view.</p>'; break;
            }
        }
        function populateThreadList(threads) { /* ... (content unchanged) ... */ 
            if(!threadsDisplayArea || !currentChannelData) return; threadsDisplayArea.innerHTML = '';
            if (!threads || threads.length === 0) { threadsDisplayArea.innerHTML = `<p class="text-gray-400 text-center py-4">No ${currentChannelData?.type === 'imageboard' ? 'posts' : 'threads'} here.</p>`; return; }
            threadsDisplayArea.classList.remove('imageboard-gallery');
            const clickHandler = (th) => { if (socket?.connected && currentChannelData) { currentViewedThreadId = th.threadId; currentViewedThreadTitle = th.title || (currentChannelData.type === 'imageboard' ? "Image Post" : "Thread"); socket.emit('getThreadContent', { channelName: currentChannelData.name, threadId: th.threadId }); }};
            if (currentChannelData.type === 'imageboard') {
                threadsDisplayArea.classList.add('imageboard-gallery');
                threads.forEach(th => { /* ... imageboard item creation ... */ 
                    if (th.opImageUrl) { const item = document.createElement('div'); item.className = 'gallery-item group relative aspect-square overflow-hidden rounded-lg cursor-pointer bg-gray-800 shadow-lg'; item.dataset.threadId = th.threadId; const img = document.createElement('img'); img.src = escapeHTML(th.opImageUrl); img.alt = escapeHTML(th.title); img.className = 'w-full h-full object-cover transition-transform duration-300 group-hover:scale-105'; img.onerror = function() { this.src = 'https://placehold.co/300x300?text=Error';}; const overlay = document.createElement('div'); overlay.className = 'gallery-item-overlay absolute inset-0 bg-gradient-to-t from-black/70 via-black/30 to-transparent group-hover:from-black/80 flex flex-col justify-end p-3 opacity-0 group-hover:opacity-100'; overlay.innerHTML = `<h4 class="font-semibold text-sm text-white truncate">${escapeHTML(th.title)||"Untitled"}</h4><p class="text-xs text-gray-300">R:${th.replyCount||0}|U:${th.upvotes||0}</p>`; item.appendChild(img); item.appendChild(overlay); item.addEventListener('click', () => clickHandler(th)); threadsDisplayArea.appendChild(item); }
                    else { const ph = document.createElement('div'); ph.className = 'p-3 border border-dashed border-gray-600 rounded-md text-center text-gray-500 text-sm aspect-square cursor-pointer'; ph.innerHTML = `<div>${escapeHTML(th.title||'Post')}</div><div class='text-xs'>No preview</div>`; ph.dataset.threadId = th.threadId; ph.addEventListener('click', () => clickHandler(th)); threadsDisplayArea.appendChild(ph); }
                });
            } else { 
                threads.forEach(th => { /* ... regular thread item creation ... */ 
                    const item = document.createElement('div'); item.classList.add('thread-list-item'); item.dataset.threadId = th.threadId; if (th.threadId === currentViewedThreadId) item.classList.add('active-thread'); const op = th.createdBy || 'N/A'; const date = th.createdAt ? new Date(th.createdAt).toLocaleDateString() : 'N/A'; const rep = th.replyCount || 0; const up = th.upvotes || 0; const snip = th.lastMessageSnippet || '...'; item.innerHTML = `<h3 class="thread-title">${escapeHTML(th.title)}</h3><div class="thread-meta"><span>By: ${escapeHTML(op)}</span><span>On: ${date}</span><span>Replies: ${rep}</span></div><p class="thread-snippet">${escapeHTML(snip)}</p><div class="thread-actions"><button class="upvote-btn" data-thread-id="${th.threadId}"><i class="fas fa-arrow-up"></i> Upvote <span class="upvote-count">(${up})</span></button></div>`; item.addEventListener('click', (e) => { if (e.target.closest('.upvote-btn')) return; clickHandler(th); }); threadsDisplayArea.appendChild(item);
                });
            }
        }

        function initializeSocket() { /* ... (content unchanged) ... */ 
            if(authButton) authButton.disabled = true; if(retryConnectionBtn) retryConnectionBtn.disabled = true;
            if (typeof io === "undefined") { showConnectionFailedScreen("Socket.IO lib not loaded!"); return; }
            if (socket) { socket.disconnect(); socket.removeAllListeners(); }
            try { showStatus("Connecting...", "info", 0); socket = io(SERVER_URL, { reconnectionAttempts: 3, timeout: 5000 });
            } catch (error) { showConnectionFailedScreen(`Socket init error: ${error.message}`); if(retryConnectionBtn) retryConnectionBtn.disabled = false; return; }
            socket.on('connect', () => { console.log('Socket connected'); showStatus('Connected!', 'success'); if(connectionFailedContainer) connectionFailedContainer.style.display = 'none'; if (!currentUserData) showAuthScreen(); if(authButton) authButton.disabled = false; if(retryConnectionBtn) retryConnectionBtn.disabled = false; });
            socket.on('disconnect', (reason) => { showConnectionFailedScreen(reason === 'io server disconnect' ? 'Server disconnected. Login again.' : `Disconnected: ${reason}. Retrying...`); if(authButton) authButton.disabled = true; if (settingsModal?.classList.contains('modal-visible')) closeSettingsPopup(); });
            socket.on('connect_error', (err) => { showConnectionFailedScreen(`Connection Error: ${err.message || 'Server unreachable'}.`); if(authButton) authButton.disabled = true; if(retryConnectionBtn) retryConnectionBtn.disabled = false; });
            socket.on('reconnect_attempt', (num) => showStatus(`Reconnecting (attempt ${num})...`, "info", 0));
            socket.on('reconnect_failed', () => { showConnectionFailedScreen("Reconnect failed. Check server."); if(retryConnectionBtn) retryConnectionBtn.disabled = false; });
            socket.on('reconnect', () => { showStatus(`Reconnected!`, 'success'); if (!currentUserData) showAuthScreen(); else if (currentChannelData?.name) socket.emit('joinChannel', currentChannelData.name); if(authButton) authButton.disabled = false; if(retryConnectionBtn) retryConnectionBtn.disabled = false; });
            socket.on('serverConfig', applyServerConfig);
            socket.on('defaultChannelName', (name) => defaultChannelNameFromServer = name || 'general');
            socket.on('authSuccess', (data) => { isProcessingAuth = false; if(authButton) authButton.disabled = false; showStatus(data.message || "Auth successful!", 'success'); if (data.serverConfig) applyServerConfig(data.serverConfig); if (data.action === 'login' && data.userData) { currentUserData = { ...data.userData, avatarUrl: data.userData.avatarUrl || '' }; showChatUI(currentUserData); if (data.channels) populateChannelList(data.channels); else socket.emit('getChannelList'); const chToJoin = data.userData.lastChannel || defaultChannelNameFromServer; const findAndSwitch = () => { if (allChannelsCache.find(c => c.name === chToJoin)) switchChannel(chToJoin); else if (allChannelsCache.length > 0) switchChannel(allChannelsCache[0].name); else { showView('none'); if(mainChannelNameHeaderDOM) mainChannelNameHeaderDOM.textContent = "No Channels"; } }; if (data.channels) findAndSwitch(); if(data.recentGlobalPosts) renderRecentPosts(data.recentGlobalPosts); } else if (data.action === 'register') { isRegisterMode = false; updateAuthUI(); if(usernameInput) usernameInput.value = ''; if(passwordInput) passwordInput.value = ''; showStatus(data.message || "Registered! Please login.", 'success'); } });
            socket.on('authError', (data) => { isProcessingAuth = false; if(authButton) authButton.disabled = false; if(authErrorMessage) { authErrorMessage.textContent = data.message || "Auth failed."; authErrorMessage.style.display = 'block';} showStatus(data.message || "Auth failed.", 'error'); });
            socket.on('channelList', (channels) => { populateChannelList(channels); if (currentUserData && !currentChannelData && channels?.length > 0) { const chToJoin = currentUserData.lastChannel || defaultChannelNameFromServer || channels[0].name; if (allChannelsCache.find(c => c.name === chToJoin)) switchChannel(chToJoin); else if (allChannelsCache.length > 0) switchChannel(allChannelsCache[0].name); } });
            socket.on('newMessage', (msgData) => { if (currentChannelData?.name === msgData.channel && currentView === 'chat') addMessageToDOM(msgData, messageListContainerDOM); });
            
            // MODIFIED: channelMessages handler to ensure scroll to bottom
            socket.on('channelMessages', (data) => { 
                if (data.channel === currentChannelData?.name) {
                    currentChannelData.type = data.type; currentChannelData.canWrite = data.canWrite; currentChannelData.messageCharLimit = data.messageCharLimit;
                    if(messageListContainerDOM) { 
                        messageListContainerDOM.innerHTML = ''; 
                        messageListContainerDOM.className = 'flex-1 p-4 overflow-y-auto space-y-1'; // Ensure class for scrolling
                        if (data.type === 'announcements') messageListContainerDOM.classList.add('message-list-announcements');
                        if (Array.isArray(data.messages)) data.messages.forEach(msg => addMessageToDOM(msg, messageListContainerDOM));
                        // Ensure scroll to bottom after messages are populated
                        setTimeout(() => { messageListContainerDOM.scrollTop = messageListContainerDOM.scrollHeight; }, 0);
                    }
                    showStatus(`Joined #${currentChannelData.name}`, 'success', 1500);
                    if(generalMessageInput) generalMessageInput.disabled = !currentChannelData.canWrite;
                    if(generalSendButton) generalSendButton.disabled = !currentChannelData.canWrite;
                    if(channelReadonlyIndicator) channelReadonlyIndicator.style.display = currentChannelData.canWrite ? 'none' : 'inline-block';
                    updateCharCounter(generalMessageInput, generalCharCounter, currentChannelData.messageCharLimit);
                    let placeholder = `Message #${currentChannelData.name}`;
                    if (data.type === 'announcements') placeholder = `Announcement (Markdown)...`;
                    else if (data.type === 'imageboard') placeholder = `Use "Create New Image Post".`;
                    if(currentChannelData.messageCharLimit && data.type !== 'imageboard') placeholder += ` (Limit: ${currentChannelData.messageCharLimit})`;
                    if(generalMessageInput) generalMessageInput.placeholder = placeholder;
                    if(currentChannelData.canWrite && (data.type === 'chat' || data.type === 'announcements') && generalMessageInput) generalMessageInput.focus();
                    showView('chat'); 
                } 
            });
            socket.on('threadList', (data) => { /* ... (content unchanged) ... */ 
                if (data.channel === currentChannelData?.name) {
                    currentChannelData.type = data.type; currentChannelData.canWrite = data.canWrite; currentChannelData.messageCharLimit = data.messageCharLimit;
                    populateThreadList(data.threads); showStatus(`Viewing ${data.type === 'imageboard' ? 'gallery' : 'threads'} in #${currentChannelData.name}`, 'success', 1500);
                    if(createNewThreadBtn) { createNewThreadBtn.disabled = !currentChannelData.canWrite; createNewThreadBtn.style.display = currentChannelData.canWrite ? 'block' : 'none'; }
                    if(channelReadonlyIndicator) channelReadonlyIndicator.style.display = 'none';
                    showView('threads');
                }
            });
            // MODIFIED: threadContent handler to ensure replies scroll to bottom
            socket.on('threadContent', (data) => {
                if (data.threadId === currentViewedThreadId && data.channelName === currentChannelData?.name) {
                    if(threadOpMessageContainer) threadOpMessageContainer.innerHTML = '';
                    if(threadRepliesContainer) threadRepliesContainer.innerHTML = '';
                    if (data.opMessage) { /* ... op message rendering ... */ 
                        if (data.type === 'imageboard' && data.opMessage.text?.match(/^(https?:\/\/[^\s]+?\.(?:png|jpe?g|gif|webp|bmp|svg))$/i)) {
                            const imgContainer = document.createElement('div'); imgContainer.className = 'mb-4 p-2 bg-gray-800 rounded-lg text-center';
                            imgContainer.innerHTML = `<img src="${escapeHTML(data.opMessage.text)}" alt="OP Image" class="max-w-full max-h-[70vh] inline-block rounded-md shadow-md" onclick="openImageModal(this.src)">`;
                            if(threadOpMessageContainer) threadOpMessageContainer.appendChild(imgContainer);
                            const opDetails = document.createElement('div'); opDetails.className = 'text-xs text-gray-400 text-center mb-2';
                            opDetails.innerHTML = `Posted by ${escapeHTML(data.opMessage.sender)} on ${new Date(data.opMessage.timestamp).toLocaleString()}`;
                            if(threadOpMessageContainer) threadOpMessageContainer.appendChild(opDetails);
                        } else addMessageToDOM(data.opMessage, threadOpMessageContainer, true);
                    } else if(threadOpMessageContainer) threadOpMessageContainer.innerHTML = '<p>OP not found.</p>';
                    if (data.replies?.isArray) data.replies.forEach(reply => addMessageToDOM(reply, threadRepliesContainer, false, true));
                    // Ensure replies scroll to bottom
                    setTimeout(() => { if(threadRepliesContainer) threadRepliesContainer.scrollTop = threadRepliesContainer.scrollHeight; }, 0);
                    if(singleThreadTitleHeader) singleThreadTitleHeader.textContent = data.title || currentViewedThreadTitle;
                    if(backToThreadsChannelNameSpan) backToThreadsChannelNameSpan.textContent = currentChannelData.name;
                    const replyLimit = data.replyCharLimit || currentChannelData?.messageCharLimit;
                    updateCharCounter(replyMessageInput, replyCharCounter, replyLimit);
                    if(replyMessageInput) replyMessageInput.placeholder = replyLimit ? `Reply... (Limit: ${replyLimit})` : "Reply...";
                    const canReply = data.canWriteReplies !== undefined ? data.canWriteReplies : currentChannelData?.canWrite;
                    if(replyMessageInput) replyMessageInput.disabled = !canReply; if(submitReplyBtn) submitReplyBtn.disabled = !canReply;
                    showView('singleThread');
                }
            });
            socket.on('newThreadCreated', (data) => { /* ... (content unchanged) ... */ 
                if (data.channelName === currentChannelData?.name && (currentView === 'threads' || currentView === 'createThread')) socket.emit('joinChannel', currentChannelData.name); 
                if (currentUserData && data.threadSummary?.createdBy === currentUserData.username) { if(newThreadTitleInput) newThreadTitleInput.value = ''; if(newThreadOpMessageTextarea) newThreadOpMessageTextarea.value = ''; updateCharCounter(newThreadOpMessageTextarea, threadCreateCharCounter, currentChannelData?.messageCharLimit); }
            });
            socket.on('newReplyInThread', (data) => { /* ... (content unchanged, relies on addMessageToDOM for scroll) ... */ 
                if (data.threadId === currentViewedThreadId && currentView === 'singleThread') addMessageToDOM(data.reply, threadRepliesContainer, false, true);
                const threadItem = threadsDisplayArea?.querySelector(`.thread-list-item[data-thread-id="${data.threadId}"] .thread-meta span:nth-child(3)`); 
                if (threadItem && data.newReplyCount !== undefined) threadItem.textContent = `Replies: ${data.newReplyCount}`;
            });
            socket.on('threadListUpdated', (data) => { /* ... (content unchanged) ... */ 
                if (data.channelName === currentChannelData?.name && data.threadId) { 
                    const item = threadsDisplayArea?.querySelector(`.thread-list-item[data-thread-id="${data.threadId}"]`);
                    if(item) { const count = item.querySelector('.upvote-btn .upvote-count'); if(count && data.upvotes !== undefined) count.textContent = `(${data.upvotes})`; const snip = item.querySelector('.thread-snippet'); if(snip && data.lastMessageSnippet) snip.innerHTML = escapeHTML(data.lastMessageSnippet); }
                }
            });
            socket.on('channelError', (data) => showStatus(data.message, 'error'));
            socket.on('messageError', (data) => { showStatus(data.message, 'error'); if (currentView === 'chat' && generalMessageInput?.disabled && currentChannelData) generalMessageInput.disabled = !currentChannelData.canWrite; });
            socket.on('threadError', (data) => { showStatus(data.message, 'error'); if(submitNewThreadBtn) submitNewThreadBtn.disabled = false; });
            socket.on('channelSuccess', (data) => { showStatus(data.message, 'success'); if (data.action === 'channelCreated' || data.action === 'channelDeleted') { socket.emit('getChannelList'); if (data.action === 'channelDeleted' && currentChannelData?.name === data.channelName) { currentChannelData = null; showView('none'); if(mainChannelNameHeaderDOM) mainChannelNameHeaderDOM.textContent = "_select_channel_"; } } if(newChannelNameInput) newChannelNameInput.value = ''; if(adminStatus) { adminStatus.textContent = data.message; adminStatus.className = 'text-xs text-green-500 mt-1'; } });
            socket.on('moderationSuccess', (data) => showStatus(data.message, 'success'));
            socket.on('moderationError', (data) => showStatus(data.message, 'error'));
            socket.on('threadSuccess', (data) => { showStatus(data.message, 'success'); if(submitNewThreadBtn) submitNewThreadBtn.disabled = false; });
            socket.on('userSuccess', (data) => { if (data.message === 'Avatar updated successfully.' && data.newAvatarUrl !== undefined) { if (avatarUpdateStatus) { avatarUpdateStatus.textContent = 'Avatar updated!'; avatarUpdateStatus.className = 'text-xs text-green-400'; } if (currentUserData) currentUserData.avatarUrl = data.newAvatarUrl; if (currentUserAvatarPreview) currentUserAvatarPreview.src = data.newAvatarUrl || 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; showStatus('Avatar updated!', 'success'); } });
            socket.on('userError', (data) => { if (avatarUpdateStatus && (data.message.includes('avatar') || data.message.includes('URL'))) { avatarUpdateStatus.textContent = `Error: ${data.message}`; avatarUpdateStatus.className = 'text-xs text-red-400'; } else { showStatus(data.message, 'error'); } });
            socket.on('onlineUserListUpdate', (users) => renderOnlineUserList(users || {}));
            socket.on('recentGlobalPosts', renderRecentPosts);
            socket.on('newGlobalPost', prependNewPost);
            socket.on('postSuccess', (data) => showStatus(data.message, 'success'));
        }

        function handleAuthAction() { /* ... (content unchanged) ... */ 
            if (isProcessingAuth) return; isProcessingAuth = true; if(authButton) authButton.disabled = true; 
            const u = usernameInput.value.trim(); const p = passwordInput.value.trim(); 
            if(authErrorMessage) authErrorMessage.style.display = 'none'; 
            if (!u || !p) { if(authErrorMessage) { authErrorMessage.textContent = 'Username/password required.'; authErrorMessage.style.display = 'block';} isProcessingAuth = false; if(authButton) authButton.disabled = false; return; } 
            if (!socket?.connected) { if(authErrorMessage) { authErrorMessage.textContent = 'Not connected.'; authErrorMessage.style.display = 'block';} if (!socket) initializeSocket(); isProcessingAuth = false; return; } 
            socket.emit(isRegisterMode ? 'register' : 'login', { username:u, password:p });
        }
        function sendMessageToServer() { /* ... (content unchanged) ... */ 
            const text = generalMessageInput.value;
            if (!currentChannelData?.name || !currentUserData) { showStatus("Not in channel/logged in.", "error"); return; }
            if (!socket?.connected) { showStatus("Not connected.", "error"); return; }
            if (!currentChannelData.canWrite) { showStatus("Channel is read-only.", "error"); return; }
            if (currentChannelData.messageCharLimit && text.length > currentChannelData.messageCharLimit) { showStatus(`Exceeds limit of ${currentChannelData.messageCharLimit}.`, "error"); return; }
            if (!text.trim()) return;
            socket.emit('sendMessage', { text: text.trim(), channel: currentChannelData.name });
            generalMessageInput.value = ''; updateCharCounter(generalMessageInput, generalCharCounter, currentChannelData.messageCharLimit); generalMessageInput.focus();
        }
        function switchChannel(newChannelName) { /* ... (content unchanged) ... */ 
            if (newChannelName === currentChannelData?.name && currentView !== 'none') return;
            if (!currentUserData) { showAuthScreen(); return; }
            showStatus(`Joining #${newChannelName}...`, 'info', 0);
            const newChInfo = allChannelsCache.find(ch => ch.name === newChannelName);
            if (!newChInfo) { showStatus(`Channel ${newChannelName} not found.`, 'error'); return; }
            currentChannelData = { name: newChInfo.name, type: newChInfo.type, canWrite: false, messageCharLimit: newChInfo.messageCharLimit };
            if(channelListElement) channelListElement.querySelectorAll('.channel-item').forEach(item => item.classList.toggle('active', item.dataset.channelName === newChannelName));
            [messageListContainerDOM, threadsDisplayArea, threadOpMessageContainer, threadRepliesContainer].forEach(el => { if(el) el.innerHTML = '<p class="text-center p-4">Loading...</p>'; });
            [generalMessageInput, generalSendButton].forEach(el => { if(el) el.disabled = true; });
            if(channelReadonlyIndicator) channelReadonlyIndicator.style.display = 'none';
            [generalCharCounter, replyCharCounter, threadCreateCharCounter].forEach(el => updateCharCounter(null, el, null)); // Reset counters
            if (socket?.connected) socket.emit('joinChannel', newChannelName);
            else { showStatus("Not connected.", "error"); showAuthScreen(); }
        }
        function handleCreateChannel() { /* ... (content unchanged) ... */ 
            const name = newChannelNameInput.value.trim(); const type = newChannelTypeSelect.value; let writable = newChannelWritableCheckbox.checked;
            if (!name) { if(adminStatus) {adminStatus.textContent = 'Name empty.'; adminStatus.className = 'text-xs text-red-500';} return; }
            if (!/^[a-zA-Z0-9_-]+$/.test(name)) { if(adminStatus) {adminStatus.textContent = 'Invalid name chars.'; adminStatus.className = 'text-xs text-red-500';} return; }
            if (!socket?.connected) { if(adminStatus) {adminStatus.textContent = 'Not connected.'; adminStatus.className = 'text-xs text-red-500';} return; }
            if(adminStatus) {adminStatus.textContent = 'Creating...'; adminStatus.className = 'text-xs text-gray-500';}
            socket.emit('createChannel', { channelName: name, channelType: type, isPubliclyWritable: writable });
        }
        function handleDeleteChannel(channelName) { /* ... (content unchanged) ... */ 
            if (!channelName || !confirm(`Delete channel #${channelName}?`)) return;
            if (!socket?.connected) { showStatus("Not connected.", "error"); return; }
            showStatus(`Deleting #${channelName}...`, "info"); socket.emit('deleteChannel', channelName);
        }
        function handleLogout() { /* ... (content unchanged) ... */ 
            currentUserData = null; currentChannelData = null; allChannelsCache = [];
            if(usernameDisplay) usernameDisplay.textContent = 'Not Logged In';
            if (settingsModal?.classList.contains('modal-visible')) closeSettingsPopup();
            [channelListElement, messageListContainerDOM, threadsDisplayArea, threadOpMessageContainer, threadRepliesContainer].forEach(el => { if(el) el.innerHTML = '';});
            if(mainChannelNameHeaderDOM) mainChannelNameHeaderDOM.textContent = '_select_channel_';
            if(generalMessageInput) { generalMessageInput.value = ''; generalMessageInput.disabled = true; }
            if(generalSendButton) generalSendButton.disabled = true;
            isProcessingAuth = false; isRegisterMode = false; showAuthScreen(); showStatus("Logged out.", "success");
        }
        function handleSubmitNewThread() { /* ... (content unchanged) ... */ 
            const title = newThreadTitleInput.value.trim(); const opMsg = newThreadOpMessageTextarea.value.trim();
            if (!currentChannelData || (currentChannelData.type !== 'forum' && currentChannelData.type !== 'imageboard')) { showStatus("Not in forum/imageboard.", "error"); return; }
            if (!currentChannelData.canWrite) { showStatus("Read-only channel.", "error"); return; }
            if (!title) { showStatus("Title empty.", "error"); newThreadTitleInput.focus(); return; }
            if (!opMsg) { showStatus(currentChannelData.type === 'imageboard' ? "Image URL empty." : "Message empty.", "error"); newThreadOpMessageTextarea.focus(); return; }
            const limit = currentChannelData.opMessageCharLimit || currentChannelData.messageCharLimit;
            if (limit && opMsg.length > limit) { showStatus(`Exceeds limit of ${limit}.`, "error"); return; }
            if (socket?.connected) { if(submitNewThreadBtn) submitNewThreadBtn.disabled = true; showStatus("Creating post...", "info", 0); socket.emit('createThread', { channelName: currentChannelData.name, title: title, opMessageText: opMsg }); }
            else showStatus("Not connected.", "error");
        }
        function handleSubmitReply() { /* ... (content unchanged) ... */ 
            if (!replyMessageInput) { showStatus("Reply input not found.", "error"); return; }
            const text = replyMessageInput.value.trim();
            if (!currentChannelData || !currentViewedThreadId) { showStatus("No active channel/thread.", "error"); return; }
            if (!text) { showStatus("Reply empty.", "error"); replyMessageInput.focus(); return; }
            const limit = currentChannelData.replyCharLimit || currentChannelData.messageCharLimit;
            if (limit && text.length > limit) { showStatus(`Reply exceeds limit of ${limit}.`, "error"); return; }
            if (socket?.connected) { if(submitReplyBtn) submitReplyBtn.disabled = true; showStatus("Posting reply...", "info", 0); socket.emit('replyToThread', { channelName: currentChannelData.name, threadId: currentViewedThreadId, replyText: text }); replyMessageInput.value = ''; updateCharCounter(replyMessageInput, replyCharCounter, limit); if(submitReplyBtn) submitReplyBtn.disabled = false; }
            else showStatus("Not connected.", "error");
        }

        document.addEventListener('DOMContentLoaded', () => {
            [authContainer, sidebar, mainChatArea, connectionFailedContainer, serverBannerContainer].forEach(el => { if(el) el.style.display = 'none';});
            loadGrapePacksFromStorage(); initializeSocket(); adjustSidebarForMobile();
            if(authButton) authButton.addEventListener('click', handleAuthAction);
            [usernameInput, passwordInput].forEach(el => { if(el) el.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleAuthAction(); }); });
            if(toggleAuthMode) toggleAuthMode.addEventListener('click', () => { isRegisterMode = !isRegisterMode; updateAuthUI(); });
            if(generalSendButton) generalSendButton.addEventListener('click', sendMessageToServer);
            if(generalMessageInput) generalMessageInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessageToServer(); } });
            if (customInputAreaWrapper && generalMessageInput) customInputAreaWrapper.addEventListener('click', (e) => { if (e.target !== generalMessageInput && !generalMessageInput.disabled) generalMessageInput.focus(); });
            [generalMessageInput, replyMessageInput, newThreadOpMessageTextarea, createPostInput].forEach(el => { if (!el) return; let counterId; if (el.id === 'create-post-input') counterId = 'create-post-char-count'; else counterId = el.id.replace('-input', '-char-counter').replace('-op-message', '-create-char-counter').replace('general-message-input','general-char-counter'); const counter = document.getElementById(counterId); if (counter) { el.addEventListener('input', () => { let lim; if (el.id === 'create-post-input') lim = el.maxLength || 140; else lim = currentChannelData?.messageCharLimit || (el === replyMessageInput ? (currentChannelData?.replyCharLimit || currentChannelData?.messageCharLimit) : null) || (el === newThreadOpMessageTextarea ? (currentChannelData?.opMessageCharLimit || currentChannelData?.messageCharLimit) : null); updateCharCounter(el, counter, lim); }); if (el.id === 'create-post-input') updateCharCounter(el, counter, el.maxLength || 140); } });
            if(retryConnectionBtn) retryConnectionBtn.addEventListener('click', () => { if(connectionFailedContainer) connectionFailedContainer.style.display = 'none'; initializeSocket(); });
            if(channelListElement) channelListElement.addEventListener('click', (e) => { const chItem = e.target.closest('.channel-item'); const delBtn = e.target.closest('.delete-channel-btn'); if (delBtn) { e.preventDefault(); e.stopPropagation(); handleDeleteChannel(delBtn.dataset.channelToDelete); } else if (chItem?.dataset.channelName) { e.preventDefault(); switchChannel(chItem.dataset.channelName); } });
            if(threadsDisplayArea) threadsDisplayArea.addEventListener('click', (e) => { const upvoteBtn = e.target.closest('.upvote-btn'); if (upvoteBtn?.dataset.threadId) { e.preventDefault(); if (!currentChannelData || !currentUserData) { showStatus("Login/select channel.", "error"); return; } socket.emit('toggleUpvoteThread', { channelName: currentChannelData.name, threadId: upvoteBtn.dataset.threadId }); } });
            if(createChannelButton) createChannelButton.addEventListener('click', handleCreateChannel);
            if(logoutButton) logoutButton.addEventListener('click', handleLogout);
            if(createNewThreadBtn) createNewThreadBtn.addEventListener('click', () => { if (currentChannelData?.canWrite) showView('createThread'); else showStatus("Cannot create posts here.", "error"); });
            if(backToThreadsFromCreateBtn) backToThreadsFromCreateBtn.addEventListener('click', () => showView('threads'));
            if(submitNewThreadBtn) submitNewThreadBtn.addEventListener('click', handleSubmitNewThread);
            if(backToThreadsBtn) backToThreadsBtn.addEventListener('click', () => { if (currentChannelData) socket.emit('joinChannel', currentChannelData.name); else showView('chat'); currentViewedThreadId = null; currentViewedThreadTitle = ""; });
            if(submitReplyBtn) submitReplyBtn.addEventListener('click', handleSubmitReply);
            if(replyMessageInput) replyMessageInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSubmitReply(); }});
            if(newChannelTypeSelect && newChannelWritableCheckbox) { newChannelTypeSelect.addEventListener('change', (e) => { newChannelWritableCheckbox.disabled = e.target.value === 'announcements'; if(e.target.value === 'announcements') newChannelWritableCheckbox.checked = false; }); if (newChannelTypeSelect.value === 'announcements') { newChannelWritableCheckbox.checked = false; newChannelWritableCheckbox.disabled = true; } }
            if (updateAvatarButton && avatarUrlInput) { updateAvatarButton.addEventListener('click', () => { const url = avatarUrlInput.value.trim(); if (socket?.connected) { if (url === '' || url.startsWith('http')) { socket.emit('updateAvatar', { avatarUrl: url }); if(avatarUpdateStatus) avatarUpdateStatus.textContent = 'Updating...'; } else if(avatarUpdateStatus) avatarUpdateStatus.textContent = 'Invalid URL.'; } else if(avatarUpdateStatus) avatarUpdateStatus.textContent = 'Not connected.'; }); }
            if (createPostBtn && createPostInput && createPostStatus && createPostCharCount) { createPostBtn.addEventListener('click', () => { const text = createPostInput.value.trim(); createPostStatus.textContent = ''; if (!text) { createPostStatus.textContent = 'Empty post.'; return; } if (text.length > createPostInput.maxLength) { createPostStatus.textContent = `Exceeds ${createPostInput.maxLength} chars.`; return; } if (!socket?.connected) { createPostStatus.textContent = 'Not connected.'; return; } socket.emit('createPost', { text: text }); createPostStatus.textContent = 'Posting...'; setTimeout(()=> { if(createPostStatus.textContent === 'Posting...') { createPostInput.value = ''; updateCharCounter(createPostInput, createPostCharCount, createPostInput.maxLength); createPostStatus.textContent = 'Posted!'; } }, 1000); setTimeout(()=> { if(createPostStatus.textContent === 'Posted!') createPostStatus.textContent = ''; }, 4000); }); }
            if (openSettingsModalButton) openSettingsModalButton.addEventListener('click', openSettingsPopup);
            if (closeSettingsModalButton) closeSettingsModalButton.addEventListener('click', closeSettingsPopup);
            if (cancelSettingsModalButton) cancelSettingsModalButton.addEventListener('click', closeSettingsPopup);
            if (userSettingsTab) userSettingsTab.addEventListener('click', () => switchSettingsTab(userSettingsTab));
            if (adminActionsTab) adminActionsTab.addEventListener('click', () => switchSettingsTab(adminActionsTab));
            if (addGrapePackUrlBtn) addGrapePackUrlBtn.addEventListener('click', handleAddGrapePackByUrl);
            if (grapePackFileInput) grapePackFileInput.addEventListener('change', handleAddGrapePackFromFile);
            if (loadedGrapePacksList) loadedGrapePacksList.addEventListener('click', handleRemoveGrapePack);
            if (fileUploadButton) fileUploadButton.addEventListener('click', () => fileUploadInput.click());
            if (fileUploadInput) fileUploadInput.addEventListener('change', handleFileUpload);
            if (emojiPickerButton) emojiPickerButton.addEventListener('click', toggleEmojiPicker);
            if (stickerPickerButton) stickerPickerButton.addEventListener('click', toggleStickerPicker);
            document.addEventListener('click', (event) => {
                if (emojiPickerPanel?.style.display === 'grid' && !emojiPickerPanel.contains(event.target) && !emojiPickerButton?.contains(event.target)) toggleEmojiPicker();
                if (stickerPickerPanel?.style.display === 'grid' && !stickerPickerPanel.contains(event.target) && !stickerPickerButton?.contains(event.target)) toggleStickerPicker();
            });
            window.addEventListener('keydown', (event) => { 
                if (event.key === 'Escape') {
                    if (settingsModal?.classList.contains('modal-visible')) closeSettingsPopup();
                    if (emojiPickerPanel?.style.display === 'grid') toggleEmojiPicker();
                    if (stickerPickerPanel?.style.display === 'grid') toggleStickerPicker();
                }
            });
            if(settingsModal) settingsModal.addEventListener('click', (e) => { if (e.target === settingsModal) closeSettingsPopup(); });
        });

        window.addEventListener('resize', adjustSidebarForMobile);
        function adjustSidebarForMobile() { /* ... (content unchanged) ... */ 
            if (!sidebar) return; 
            if (window.innerWidth < 768) sidebar.style.display = 'flex'; 
            else { sidebar.style.display = 'flex'; sidebar.classList.remove('open'); document.body.classList.remove('sidebar-open-overlay'); document.body.style.overflow = ''; }
        }
        function renderRecentPosts(posts) { /* ... (content unchanged) ... */ 
            if (!recentPostsFeedDiv) return; recentPostsFeedDiv.innerHTML = '';
            if (!posts || posts.length === 0) { recentPostsFeedDiv.innerHTML = '<p class="text-xs text-gray-500 text-center py-4">No recent posts.</p>'; return; }
            posts.slice(0, 15).forEach(p => { const el = document.createElement('div'); el.className = 'post-item text-xs bg-gray-700/40 p-2 rounded-md'; const av = p.avatarUrl || 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; const date = new Date(p.timestamp); const time = date.toLocaleTimeString([], {hour:'numeric', minute:'2-digit'}); el.innerHTML = `<div class="flex items-center mb-1"><img src="${escapeHTML(av)}" alt="${escapeHTML(p.username)}" class="w-4 h-4 rounded-full mr-1.5 object-cover bg-gray-600" onerror="this.style.display='none'; this.nextSibling.style.display='inline-flex';"><span class="w-4 h-4 rounded-full items-center justify-center mr-1.5 bg-gray-600 text-xs" style="display:none;">${escapeHTML(p.username.substring(0,1).toUpperCase())}</span><span class="font-semibold text-gray-300 truncate mr-1">${escapeHTML(p.username)}</span><span class="ml-auto text-gray-500 text-[10px]" title="${date.toLocaleString()}">${time}</span></div><p class="text-gray-300 leading-snug break-words">${escapeHTML(p.text)}</p>`; recentPostsFeedDiv.appendChild(el); });
            recentPostsFeedDiv.scrollTop = 0;
        }
        function prependNewPost(post) { /* ... (content unchanged) ... */ 
            if (!recentPostsFeedDiv || !post) return;
            const ph = recentPostsFeedDiv.querySelector('p'); if (ph?.textContent.includes('No recent posts.')) recentPostsFeedDiv.innerHTML = '';
            const el = document.createElement('div'); el.className = 'post-item text-xs bg-gray-700/40 p-2 rounded-md'; const av = post.avatarUrl || 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; const date = new Date(post.timestamp); const time = date.toLocaleTimeString([], {hour:'numeric', minute:'2-digit'}); el.innerHTML = `<div class="flex items-center mb-1"><img src="${escapeHTML(av)}" alt="${escapeHTML(post.username)}" class="w-4 h-4 rounded-full mr-1.5 object-cover bg-gray-600" onerror="this.style.display='none'; this.nextSibling.style.display='inline-flex';"><span class="w-4 h-4 rounded-full items-center justify-center mr-1.5 bg-gray-600 text-xs" style="display:none;">${escapeHTML(post.username.substring(0,1).toUpperCase())}</span><span class="font-semibold text-gray-300 truncate mr-1">${escapeHTML(post.username)}</span><span class="ml-auto text-gray-500 text-[10px]" title="${date.toLocaleString()}">${time}</span></div><p class="text-gray-300 leading-snug break-words">${escapeHTML(post.text)}</p>`;
            recentPostsFeedDiv.insertBefore(el, recentPostsFeedDiv.firstChild);
            while (recentPostsFeedDiv.children.length > 15) recentPostsFeedDiv.removeChild(recentPostsFeedDiv.lastChild);
        }
        function renderOnlineUserList(users) { /* ... (content unchanged) ... */ 
            if (!onlineUserListDiv) return; onlineUserListDiv.innerHTML = ''; const count = Object.keys(users).length;
            if (count === 0) { onlineUserListDiv.innerHTML = '<p class="text-xs text-gray-500">No users online.</p>'; return; }
            for (const username in users) { const u = users[username]; const item = document.createElement('div'); item.className = 'user-item flex items-center space-x-2 p-1 rounded hover:bg-gray-600/50 cursor-pointer'; item.title = `${username} (${u.status||'online'})`; const av = u.avatarUrl || 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; const stColor = 'bg-green-400'; item.innerHTML = `<div class="relative flex-shrink-0"><img src="${escapeHTML(av)}" alt="${escapeHTML(username)}" class="w-6 h-6 rounded-full object-cover bg-gray-600" onerror="this.style.display='none'; this.nextSibling.style.display='inline-flex';"><span class="w-6 h-6 rounded-full inline-flex items-center justify-center bg-gray-600 text-sm" style="display:none;">${escapeHTML(username.substring(0,1).toUpperCase())}</span><span class="absolute bottom-0 right-0 block h-1.5 w-1.5 rounded-full ${stColor} ring-1 ring-gray-800"></span></div><span class="text-sm text-gray-200 truncate">${escapeHTML(username)}</span>`; onlineUserListDiv.appendChild(item); }
        }

    </script>
</body>
</html>
